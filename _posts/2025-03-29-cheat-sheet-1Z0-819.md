## Cheat sheet 1Z0-819

This is a new format I will try with collapsable sections. In this post I will summarize [the book](https://www.amazon.com/gp/product/B08DF4R2V9/ref=ppx_yo_dt_b_d_asin_title_351_o00?ie=UTF8&psc=1) with a lot of specific on all the topics. For now I'll follow the chapter order of the book, but it is a work in progress.

Note: these collapsables do not render well on my public page. I'll try to fix it after the test, I'm not happy with the rendering anyway.

<details>
<summary>Chapter 1: Welcome to Java</summary>


### Learning about the Java environment

- JDK contains compiler (javac), launcher (java), archiver command (jar) and API documentation (javadoc) command
- javac generates bytecode
- java launches the JVM before running the code
- JVM runs the bytecode .class files
- In Java context, API's are classes like StringBuilder that are built in and can be used

### Identifying benefits of Java
- Object oriented
- Encapsulation
- Platform independent
- Robust (garbage collection, no memory leaks)
- Simple (simpler than C++)
- Secure (because it runs inside JVM)
- Multithreaded
- Backward compatibility

### Understanding the Java class structure

- Variables hold the state of the program, methods operate on that state
- Method signature is only method name + parameters
- Method declaration is method signature + modifiers + return type (+ type variables?)
- /* ...*/ is multiline comment
- /** ... */ is javadoc comment
- When multiple classes are in one file, only one can be public
- The public class in a file needs to match the filename, otherwise the file won't compile
- The main method lets the JVM call the code. It is the gateway between the code and the JVM.
- A file must have .java extension to compile
- To compile: ``` javac Zoo.java ```
- To run: ``` java Zoo ``` (no .class extension)
- if no static main method in class we execute, the JVM process will throw error and terminate.
- ```String[] args```, ```String args[]``` and ```String... args``` are okay.
- ```String [] options``` and ```String options []``` are okay too.

This code snippet compiles class Zoo and then supplies the static main function with two arguments "Bronx" and "Harlem Park". Note the quotation marks to deal with a space in Harlem Park:

```
javac Zoo.java
java Zoo Bronx "Harlem Park"
```

All command line arguments are treated as Strings. 

#### Running a program in one line:

You can do without javac if you want to compile and run a single file:
```
java Zoo.java  // with extra arguments if you want
```
This feature is called _single-file source-code_ programs, only meant when running single file. If there's a compiletime error, you get an error: compilation failed. With single-file source-code, no .class file is created, the bytecode is stored in memory. Single-file source-code can only import code from the JDK library, no other libraries.

### Understanding package declarations and imports

- Wildcard in import statement: * means all classes in a package but only on that level, not deeper, no child packages.
- Everything in java.lang doesn't need import statement, import is automatically done.
- A wildcard only matches file names, so nothing is imported if there are only packages in it.
- You can only have one wildcard and it must be at the end.
- You cannot import methods, only class names with a wildcard.
- When a class you used is found in multiple packages, compiler error.
- If you explicitly import a class name, it takes precedence over wildcard.
- Two explicit imports of classes with the same name gives compiler error.
- If you want to use two classes with the same name, use the FQN (java.sql.Date) in the code to remove ambiguity.
- You can even choose to import nothing and use FQN in your code.
- single-file source-code method works only if class/file doesn't rely on other file.

#### Compiling with wildcards

- You can use * to specify that you want to include all files in a directory: ```javac packagea/*.java```
- Such a wildcard does not include subdirectories.
- Run it by: ```java packagea.ClassWithMain```
- Compiled files are placed in the same directory as the source code by default.
- ```-d``` is the command that helps select another directory for .class files.

```javac -d compiledclasses packagea/ClassA.java packageb/*.java```

This line puts ClassA.class and all the files from packageb in a folder 'compiledclasses'. The package structure is preserved! So ClassA .class is in compiledclasses/packagea/ClassA.class.

- To run the program you need to provide the classpath -cp, -classpath or --class-path.

```
java -cp compiledclasses packagea/ClassA
```

#### Compiling with JAR files

To run a program and include files in it that are in a JAR file, do the following:

```
java -cp ".;C\temp\someFolder;C:\temp\myJar.jar" myPackage.MyClass
```

You run a program where the main function is in the main class, which is in the current directory. This is what the dot at the start is for. All other locations are in the string as well, separated by semicolons. The jar file is included as a file in this string. You can use wildcard * when there are multiple JARs in a directory that you want to include all:

```
java -cp "C:\temp\folderWithJars\*" myPackage.MyClass
```

#### Creating a JAR file

Simple form, creating jar file from all files in current directory (both work):

```
jar -cvf myNewFile.jar
jar --create --verbose --file myNewFile.jar
```

You can specify directory instead of the current one using -C:

```
jar -cvf myNewFile.jar -C somedirectory
```

#### Ordering elements in a class

- Only a class declaration is required. Class can be empty.
- Package declaration must be first line in the file (comments excluded, those can be anywhere)
- Import statements immediately after package declaration
- Class declaration immediately after import statements
- Fields and methods can be in any order, fields at the end of in middle is okay.

In the test, chack for line numbers. If there are line numbers and they start with one, check if packages and imports are alright. If not, the snippet won't compile.

</details>

<details>
<summary>Chapter 2: Java building blocks</summary>

### Creating objects

- Fields and instance initializer blocks are run in the order in which they appear in the file.
- The constructor runs only after that.


### Understanding data types

- short is signed (negative and positive numbers), char is not (only positive numbers. Both are 16 bit.
- ```long max = 3123456789 ``` gives compile error, number is larger dan Integer.MAX_VALUE 
- ```long max = 3123456789L ``` no compile error, the L communicates it is a long, not an int
- You can use underscores innumber lteral but not at start, end or next to decimal point.
- A float requires the letter F as prefix to the number, but only if there is a decimal point in it. 
- A decimal number without F (or f) is seen by default as a double.

_You can be tricked, watch out for missing F with float initialization! Check if the value can be misunderstood as a double._

#### Using reference types

All the examples below refer to local variables. Instance variables cannot be reassigned in the way described below. If you want to change an instance variable, it has to be done fromout an initializer block, a constructor or a method.

- Reassigning reference variable: It works when you use 'new'. Generally you need to reassign it to an object type that matches the reference type. Example:

```
String s = new String("Hello");
s = new String("Goodbye"); // correct
s = new Integer.valueOf(5); // incorrect, compile error
```

Also correct (in case of String):

```
String s = "Hello";
s = "Goodbye";
```

Also correct:
```
Integer i = Integer.valueOf(4);
Integer j = Integer.valueOf(7);
i = j; // correct
```

More example:

```
Path p = Path.of("text.txt");
p = Path.of("text2.txt");
p = Integer.valueOf(6); // incorrect, compile error
```

With primitives it is similar:

```
int t = 10;
t = 11; //okay
t = 1.3; // incorrect, t is type integer and 1.3 is type double
```

- Primitives types cannot be null, reference types can
- Reference types can be mutable or immutable. Boxed primitives and String are immutable, while most collections, StringBuilder, AtomicInteger and many others are mutable.
- Primitives do not have methods on them, reference types do.

#### Identifying identifiers

- Identifiers must beging with _, $ or a letter.
- Identifiers can include numbers but cannot start with them.
- Since Java 9, a single underscore is not allowed as an identifier
- You cannot use a reserved word as an identifier. There are 54 of them, var is not aming them. Neither are Error and Exception
- This is camelCase and this is too: CamelCase. It is convention, not a rule.
- this_is_snake_case

#### Declaring multiple variables

All below is alright. The first line are declarations, the second is declaration + initialization:

```
String s1, s2, s3;
String s4 = "Yes", s5 = "No", s6 = "Maybe";
```

Sneaky case:

```
int i1, i2, i3 = 0;  // correct, only i3 is initialized
String s1 = "hi", s2;  // also correct, s1 is initialized
```

This is forbidden because you cannot mix multiple variable types:

```
int num, String value;
```

This is also forbidden:

```
double d1, double d2;  // incorrect
double d1, d2; // correct
```

### Initializing variables

#### Creating local variables

- A local variable is defined within a constructor, method, or initializer block.
- Local variables do not have a default value and must be initialized before use.
- Trying to read an uninitialized local variable gives compile error.
- The compiler is smart and will detect local variables that might be read without being initialized. In that case you get compile error.
- Generally: compiler checks very well the occurence of uninitialized variables being read and gives error if this scenario is possible.

_"On the exam, be aware of any local variable that is declared but not being initialized in a single line."_

#### Passing constructor and method parameters

These parameters must be initialized before the method is called, obviously.

#### Defining instance and class variables

- Class variable is another word for static variable (at class level).
- Instance and class variables are given a default value on declaration. This is different from local variables. 
- Defaults of numbers is 0 or 0.0, of boolean is false, of reference types is null.

#### Introducing var

- ```var``` can only be used in local context, not for instance or class variables! (I didn't know that). You can use it as well in initializer blocks and constructors.

_"Local variable type inference works with local variables and not instance variables."_

#### Type inference of var / examples with var

- Compiler figures out the type of var. After that you cannot assign another type to it, but you can change the value.
- You might say that var behaves exactly like any specific type.
- If compiler can't figure out the type during declaration, compile error. 
- Using var thus only works if declaration and initialization happens at the same time.
- Java doesn't allow var in multiple type declarations like these: ```var a=3, b=2```
- ```var n = null``` is not allowed. Type can be any reference type.
- ```var k = (String) null``` is allowed. Compiler can infer the type.

_"Be on the lookout for var used with constructors, method parameters, or instance variables."_

_"Remember that var is only used for local variable type inference!"_

```var``` is not a reserved word, you can use it as identifier. But it is a _reserved type name_, which means you cannot use is as the name of a class, enum or interface.

Summary:
- A var is used as a local variable in a constructor, method or initializer block.
- A var cannot be used in constructor parameters, method parameters, instance variables, or class variables.
- A var is always initialized on the same line (or statement) where it is declared.
- The value of a var can change but the type cannot.
- A var cannot be initialized with a null value without a type.
- A var is no permitted in a multiple-variable declaration.
- A var is a reserved type name but not a reserved word, meaning it can be used as identifier but not as the name of a class, enum or interface.

### Managing variable scope

Method parameters count as local variables. They have the same scope as local variables within the class and are removed by the gc in the same way.

Each block ({}) has its own scope.

Within a method you can reference variables that are outside your {} scope, but they cannot reference you.

_"Identifying blocks and variable scope needs to be second nature for the exam._"

#### Reviewing scope

- Local variables: in scope from declaration to end of block.
- Instance variables: in scope from declaration until object eligible for garbage collection.
- Class variables: in scope from declaration until program ends.

### Destroying objects

#### Eligible for garbage collection

All Java objects are stored in the _heap_, also called the _free store_.

Eligible for garbage collection refers to an object's state of no longer being accessible in aprogram and therefore able to be garbage collected.

```System.gc()``` is a method that _suggest_ that the JVM start with garbage collection. But you can't force the JVM, so it might as well not happen anyway. The JVM is free to ignore the request.

#### Tracing eligibility

An object will remain on the heap until it is no longer reachable. It is no longer reachable when one of two situations occur:

- The object no longer has any references pointing to it
- All refernces to the object have gone out of scope

</details>

<details>
<summary>Chapter 3: Operators</summary>

### Understanding Java operators

#### Types of operators

#### Operator precedence

|Symbols and examples|
|--------------|
|_expr++ , expr--_|
|_++expr , --expr_|
|_- , ! , ~ , + , **(type)**_|
|_* , / , %_|
|_+ , -_|
|_<< , >> , >>>_|
|_< , > , <= , >= , **instanceof**_|
|_== , !=_|
|_& , ^, \|_|
|_&& , \|\|_|
|_ternary operator_|
|_all assignment operators_|

### Applying unary operators

A unary is one that requires exactly one operand, or variable, to function. They are ```! , + , - , ++ , -- , (type)```

#### Logical complement and negation operators

_"Beware that in Java, 1 and true or 0 and false are not interchangeable or related."_

#### Increment and decrement operators

The pre-decrement or pre-increment operator (--expr or ++ expr) returns the new value, the post-decrement and post-increment operators return the old value.

Code sample (be aware that post-increment/decrement has precedence on pre-increment/decrement):

```
int lion = 3;
int tiger = ++lion*5/lion--; // 3*5/3 as post-increment goes first
System.out.println(lion);  // 3
System.out.println(tiger);  // 5
```

### Working with binary arithmetic operators

They need two values to operate on instead of (unary) one.

#### Arithmetic operators 

Binary arithmetic operators are +,-,*,/,%

#### Numeric promotion

The rules below are foolowed when applying operators to data types:

- If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.
- If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value's data type.
- Smaller data types, namely byte, short and char, are first promoted to int any time they're used with a Java binary arithmetic operator, even if neither of the operands is int.
- After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.

For the third rule, note that unary operators are excluded from this rule. short++ is still a short.

### Assigning values

#### Casting values

These do not compile

```
float egg = 2.0 / 9;  // 2.0 is a double, so result is a double
int a = (int)5 * 2L;  // 2L is a long, so result is a long
short frog = 3 - 2.0;  // 2.0 is a long, so result is a long
```

```
short bird  = 1921222; // does not compile, value is out of range
long x = 912301398193810323; // does not compile but it would if L was added.
			      // Java interprets the literal as an int and can't cope.
```

#### Applying casting

Downcasting is often possible:

```
int trainer = (int)1.0; // stored as 1;
short a = (short)1921222; // stored as 20678
int u = (int)gf;
long m = 912301398193810323L;
```

_"Remember, casting primitives is required any time you are going from a larger numerical data type to a smaller numerical data type, or converting from a floating-point number to an integral value."_

Underflow and underflow (not in exam): when downcasting, for example from int to short, a sort of modulo may be applied. See the 'short a' example above.

#### Compound assignment operators

``` += , -= , *= , /= ```

These operators help to avoid a cast. Example:

```
long goat = 10;
int sheep = 5;
sheep = sheep * goat; // doesn't compile
sheep *= goat; // compiles. Sheep will first be cast to long, only then the multiplication is done
```

#### Assignment operator return value

Something new: an assignment is in itself an expression that returns a value. 

```
long w = 5;
long c = (w=3);
System.out.println(w);  // 3
System.out.println(c);  // 3
```

_The return value of the assignment is the value to which the left part of the assignment is set!_

Another example:

```
boolean healthy = false;
if(healthy=true)
    System.out.println("Good!");
```

While I would say this was a mistake and == was required, ```(healthy=true)``` actually returns ```true```.

### Comparing values

The ```==``` operator, applied to primitives, looks if the values are the same. When applied to objects, it sees if the two values reference the same object.

With primitives, the == returns true if the numeric values are the same, even if they are of different type (say float and int).

Equality operators (== and !=) can be used in the following three scenarios:
- Comparing two numeric or character primitives. Values are automatically promoted if not of the same type.
- Comparing two boolean values
- Comparing two objects, including null and String values.

Types cannot be mixed outside of these three cases, otherwise compile error. The following lines do not compile:

```
boolean a = true==3;
boolean b = false!="Grape";
boolean c = 10.2=="Hank";
```

_"Pay close attention to the data types when you see an equality operator on the exam. ...The exam creators also have a habit of mixing assignment operators and equality operators."_

Below an example where ```==``` returns false, even though both reference variables point to the same object:

```
File a = new File("text.txt");
File b = new File("text.txt");
File c = b;
a == b; // false
b==c; // true
```

Because b created a new object, a and b are not equal with regards to ==.

#### _instanceof_ operator

Using instanceof on two unrelated variable types gives compile error.

_"For the exam, you should know that calling instanceof on the null literal or a null reference always returns false."_

Furthermore,  ```null instanceof null``` does not compile.

#### Logical operators

- AND ```&``` is only true if both operands are true
- Inclusive OR ```|``` is only false if both operands are false
- Exclusive OR ```^``` is only true if the operands are different

#### Short-circuit operators

```&& , ||```

_Important: other dan with the logical operators, here the right side of the expression may never be evaluated if the final result can be determined by the left side of the expression._

&& and || works from left to right, while &,|,^ have no defined order. Example:

```
int hour = 10;
boolean zooOpen = true || (hour<4); // right side is never evaluated
System.out.println(zooOpen); // true
```

This principle can be used to avoid NullPointerException:

```
if(x!=null && x.getAge()<5){  // x.getAge() is not executed if x==null
    doSomething();
}
```

_"Be wary of short-circuit behavior on the exam, as questions are known to alter a variable on the right side of the expression that may never be reached."_

### Making decisions with the ternary operator

Second and third expression do not have to be the same data types, although in an assignment this must be the case. If a ternary can return a value of the wrong type, code won't compile: 

```
int animal - (stripes>9) ? 3 : "Horse"; // doesn't compile
```

Like with short-circuit operators, the third expression is not evaluated if the first expression is true. 

_"Be wary of any question that includes a ternary expression in which a variable is modified in one of the right-hand side expressions."_

</details>




<details>
<summary>Chapter 4: Making decisions</summary>

### Creating decision-making statements

#### Statements and blocks

A statement is a complete unit of execution in Java, terminated with a semicolon.

A block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.

#### The _if_ statement

_"One area where the exam writers will try to trip you up is on if statements without braces ({})."_

#### The _else_ statement

If a specific else statement cannot be reached, because an earlier statement already covers the case, the code will compile anyway.

_"Another common place the exam may try to lead you astray is by providing code where the boolean expression inside the if statement is not actually a boolean expression."_

#### The switch statement

- Beware of parentheses (mandatory)
- Use ```switch(someVar) {}```, not ```switch someVar {}```
- Each case statement requires the keyword case, followed by a value and a colon.
- This is allowed: ```case 1: case 2: ```
- This is allowed: ```switch(someVar){}```

The following datatypes are allowed for switch:
- int, byte, short, char, Integer, Byte, Short, Character, enum, String
- var is allowed if it resolves to one of those types

Note: Java 12 introduced more possibilities with switch, based on lambda's, but these are not in the exam.

The default statement can be anywhere, doesn't need to be at the end. Order can be important anyway if break statements are omitted. Say, the value sought after is not among the case statements, then it goes to default, and if default has no break, it will trickle down from there on. So if default is not at the end, at least add a break statement to it.

The default block is only executed if no other value matches, regardsless of the order.

_"The exam creators are fond of switch examples that are missing break statements!"_

Case statements need values that are any of these:
- a final constant variable (initialized with a literal value in the same expression in which it was declared)
- an enum constant
- an expression of literals (3*2)
- an expression of finals
- a literal

In general, the value must be resolved at compile time, so a value that is the result of a method running at runtime is not allowed. Furthermore, it must match the type in the switch statement (of course).

#### Numeric promotion and casting

Switch statements support numeric promotion that does not require an explicit cast. For example, If the switch expression is a short and the case an int, it will work unless the int is bigger than max short size.

### Writing _while_ loops

There is _while_ and _do/while_. In both while always has an () containing the condition. 

A while block can do without {} if there is just one statement. The following is alright.

```
int q = 1;
while (q<5)
    System.out.println(q++);
````

#### Infinite loops

Be aware that a loop should terminate somewhere.

### Constructing _for_ loops

Variables declared in the initialization block have limited scope and are only accessible in the loop. The initialization block is the first part of the for statement, before the first semicolon.

Each component of the initialization block is optional. The semicolons are mandatory, there must be two. Below is a valid infinite loop: 

```
for (;;)  
    // some code
```` 

You can add multiple terms in the for statement:

```
int x = 0;
for(long y=0, z=4; x<5 && y<10; x++, y++){  // it is important that y and z have the same type.
    System.out.println(y + "");
}
System.out.println(x + "");
```

You cannot redeclare a variable in the initialization block:

```
int x = 0;
for (int x=4; x<5;x++)   // does NOT compile
    System.out.println(x + "");   
```

But this is alright:

```
int x = 0;
for (x=4; x<5;x++)   // does compile
    System.out.println(x + "");   
```

Variables in the initialization block need to be of the same type. The following does not work for that reason:

```
int x=0;
for (long y=0, int z=4; x<5;x++){} // does not compile
```

Java allows modification of loop variables, although it is mostly bad practice. The enhanced loop is a different thing btw.

#### The for-each loop

Also called the enhanced for-loop, meant to iterate over collections. Two types can be iterated with for-each:
- A built-in Java array
- An object whose type implements java.lang.Iterable

Map doesn't implement iterable, neither do String and StringBuilder.

The for-each loop accepts var for the loop variable, just like the regular for loop.

### Controlling flow with branching

#### Nested loops

Beware not to take too much time on the exam figuring out complex nested loops.

#### Adding optional labels

If statements, switch statements and loops can all have optional labels. All code below is valid:

```
OUTER_LOOP: for (String s : list){
    // code
};
```
```
int x = 5;

MY_SWITCH: switch(x){
    case 5:
        System.out.println("Yes!");
        break;
    default:
        break;
}
```
```
A: for (int i=0; i<5; i++)
    B: for (int j=0; j<3; j++)
        System.out.printf("i=%s and j=%s\n", i,j);
```
```
MY_LABEL: System.out.println("Hi"); // this is also okay
````

The compiler is very relaxed about using optional labels. The only rule is that it needs to be followed by a statement, although assignments are not permitted. ```MY_LABEL: Integer a = 2;``` doesn't compile for that reason.

#### The _break_statement

Break statements are not limited to switch, you can put them in while, do/while and in for loop. In all cases it will end things early.

If you have added labels to your for loop(s), you can use them with the break statement like ```break PARENT_LOOP;```. By doing so you will break out of the parent loop, which might be one level higher than the child loop you would normally break out of.

This helps to avoid unnecessary continuation of a nested loop so it is handy.

#### The _continue_ statement

While the break statement breaks out of the loop entirely, the contue statement only breaks out of the current iteration. If i was 3, it will skip to i=4. You can use continue with optional label to alter the result:

```
CLEANING: for (char c='a'; c<'d'; c++){
    for (int i=1; 1<4; i++){
        if(c=='b' || i==2){
            continue CLEANING;
        }
        System.out.println(c + " " + i)
    }
]

//output:
a 1
c 1
d 1
```

The special thing is that ```continue CLEANING;``` skips all the inner i iterations and goes to the next outer c iteration right away.

#### The _return_ statement

Return breaks out of the loop and returns a value. Their benefit is that they provide more readable code.

#### Unreachable code

When break, continue or return are wrongly positioned that can cause parts of the code to be unreachable. If this is the case you get a compiler error. Think of:

```
case 6:
    break;
    someMethod();  // unreachable, compile error
```

#### Reviewing branching

There are 4 flow controls. Book provides a table with their relationships to optional labels, break and continue:

||**Allows optional lables**|**Allows _break_ statement**|**Allows _continue_ statement**|
|----|----|----|----|
|while|Yes|Yes|Yes|
|do while|Yes|Yes|Yes|
|for|Yes|Yes|Yes|
|switch|Yes|Yes|No|

Summary: switch does not allow _continue_ statement.

</details>



<details>
<summary>Chapter 5: Core Java APIs</summary>

### Creating and manipulating strings

#### Concatenation

Beware that adding strings and numbers happens from left to right. The following outputs "3c":

```
System.out.println(1 + 2 + "c"); // 3c
```

#### Important _String_ methods

- _int length()_
- _char charAt(int index)_
- _int indexOf()_
- _String substring(int beginindex)_
- _String substring(int beginIndex, int endIndex)_
- _String toLowerCase()_
- _String toUpperCase()_
- _boolean equals(Object obj)_
- _boolean equalsIgnoreCase(String str)_
- _boolean startsWith(String prefix)_
- _boolean endsWith(String suffix)_
- _String replace(char oldChar, char newChar)_
- _String replace(CharSequence target, CharSequence replacement)_
- _boolean contains(CharSequence charSeq)_
- _String strip()_
- _String stripLeading()_
- _String stripTrailing()_
- _String trim()_
- _String intern()_

strip() does everything what trim()  does but supports Unicode.

### Using the StringBuilder class

Modifying a string multiple times results in the creation of multiple new objects which is not efficient. This is what StringBuilder is for, it is a mutable type.

When StringBuilder returns itself, it is not a copy of itself but just a reference to the same object. This is different from String, where a new String object is returned. 

#### Creating a StringBuilder

Three ways:

```
StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);
```

#### Important StringBuilder methods

_**charAt(int index), indexOf(String str), length(), subString(int start, int end)**_

Important: subString() returns a String, not a StringBuilder. subString() has a one parameter variant as well with only the start position.

- StringBuilder _**append(String str)**_ 
- StringBuilder _**insert(int offset, String str)**_ 
- StringBuilder _**delete(int startindex, int endindex)**_ 
- StringBuilder _**deleteCharAt(int index)**_ 

The latter is convenient if you want to delete just one character.

_**StringBuilder replace(int start, int end, String newString)**_

This one removes positions start to end and inserts the third String parameter.

_**StringBuilder reverse()**_

_String **toString()**_

These two speak for themselves.

### Understanding equality

Using ```==``` on StringBuilder checks if the variables refer to the same object. 
StringBuilder hasn't implemented ```equals()```, so calling equals returns the same as calling ```==``` (variables referencing the same object).

With String this is different. String has implemented equals to check for the equality of the String content. If you want to check of two StringBuilder variables are referring to StringBuilder instances with the same content, you need to convert them to Strings and compare the strings.

The following does not compile because you cannot use ```==``` on different types.

```
String string = "a";
StringBuilder builder =  new StringBuilder("a");
System.out.println(string==builder); // does not compile
```

### The _String_ pool

Strings with the same content are stored as one object in the String pool, but you can avoid this by using new String(..). Also when a String is computed at runtime, it will be stored as a new String even if there is already an identical one in the String pool.

_If one String is computed at compile time and the other at runtime, ```==``` will always return false._

You can force Java to use the String pool when creating a new String using inter():

```
String name = "Hello World";
String name2 = new String("Hello World").intern();
System.out.println(name==name2); // TRUE
```

### Understanding Java arrays

```int[] numbers = new int[] {1,2,3};``` and ```int[] numbers = {1,2,3};``` are both okay.

```int a[], b;``` creates an int array (a[]) and an int (b).

As String[] is an object, it can be used in castings. Like ```String[] a = (String[]) objects````. It works if objects is indeed an array of Strings.

Note that you can store different types in an array Object[], but that this will give a runtime error ArrayStoreException.

If you initialize an arry like ```String[] b = new String[6]```, this new array will have a length of 6 whereby each value is null.

#### Searching

You can search for an element in a Java array but the results are only meaningful when the array is sorted (Arrays.sort(myArray)). 

If the value is not found, you might find a negative number. The rule for this negative number is:
- Check the position where the value you search for would be posiitioned if it was in there (the array is sorted so you can do this)
- Make this number negative and subtract 1. This is the result of Arrays.binarySearch(). 

Example:

```
int[] numbers = {2,4,6,8};
System.out.println(Arrays.binarySearch(numbers, 2)); // 0
System.out.println(Arrays.binarySearch(numbers, 5)); // -3
```

The second line gives -3 as 5 would be on position 2, make -2, subtract 1.

If the array is not sorted, the output will be kind of unpredictable.

#### Comparing

The Arrays class has a compare(array1, array2) method. Interpretation of the result is as follows:
- A negative number menas the first array is smaller than the second
- Zero means that they are equal
- A positive number means the first array is larger than the second

Note: this is the same pattern as for Comparator.

How does Java decide which array is larger?
- If arrays are identical, same size and same values at same places, compare returns 0.
- If they are the same but one has extra values at the end, that one is larger.
- You can put them next to each other and compare values until one of the arrays has a larger value than the other on that place. Then that array is the larger one.

General larger/smaller rules:
- null is smaller than any other value
- for numbers, just order them.
- for strings, one is smaller if it is a prefix of the other
- for strings/characters, numbers are smaller than letters
- for strings/characters, uppercase is smaller than lowercase

When comparing two arrays, they must be of the same type, if not, compile error.

_**Arrays.mismatch(array1, array2)**_

I had not heard of this one. Returns -1 if arrays the same, if the arrays are not the same, it returns the index where the first difference is found.

_Definition of mismatch(): finds and returns the index of the first mismatch of two int arrays, or -1 if they are identical._

Note: also works with other primitives, and also with String. Might be convenient when comparing two datasets to see where they differ.

#### Multidimensional arrays

You can be very creative when declaring a multidimensional array. The [] can be on all the places where you can put them in a onedimensional array. A nice one:

```
int[] a[], b[][]; // creates a 2D and a 3D array
```

The arrays in the array can be of different size. This is okay:

```
int[][] arr = {{1,4}, {3}, {5,6,7,8}};
```

You can go in steps:

```
int[][] a = new int[5][];
a[0] = new int[3];
a[1] = new int[7];
```

### Understanding an ArrayList

Funny, this compiles: 

```
var list = new ArrayList<>(); // arraylist of type Object
```

It is still possible to create ArrayLists without type and put 'Objects' in it. It has to do with backward compatibility.

This paragraph mentions the methods for (Array)List but they are in chapter 12 as well.

The equals() method for ArrayList only returns true if the ArrayLists are identical.

### Wrapper classes

Each primitive has a wrapper class and you can create a wrapped primitive by the .valueOf() method (Double.valueOf(1.0), Float.valueOf((float) 1.0), Byte.valueOf((byte) 1)) etc.).

**Important:** The wrapper classes are immutable.

Conversion methods you need to know for the exam:

```
int p = Integer.parsInt("123");
Integer w = Integer.valueOf("123"';

int b = Integer.parseInt("a"); // throws NumberFormatException
Integer c = Integer.valueOf("12.67"); // throws NumberFormatException
```

Remarkable: many static methods in the Integer class return int primitive. ParseInt() is only one of them.

_Generally speaking, every primitive wrapper class has a custom .parse method (.parseBoolean, .parseShort etc) to convert a String to a primitive, and a .valueOf method to convert a String to the wrapper class type._











































</details>