## Cheat sheet 1Z0-819

This is a new format I will try with collapsable sections. In this post I will summarize [the book](https://www.amazon.com/gp/product/B08DF4R2V9/ref=ppx_yo_dt_b_d_asin_title_351_o00?ie=UTF8&psc=1) with a lot of specific on all the topics. For now I'll foolow the chapter order of the book, but it is a work in progress.

<details>
<summary>Chapter 1: Welcome to Java</summary>

### Learning about the Java environment

- JDK contains compiler (javac), launcher (java), archiver command (jar) and API documentation (javadoc) command
- javac generates bytecode
- java launches the JVM before running the code
- JVM runs the bytecode .class files
- In Java context, API's are classes like StringBuilder that are built in and can be used

### Identifying benefits of Java
- Object oriented
- Encapsulation
- Platform independent
- Robust (garbage collection, no memory leaks)
- Simple (simpler than C++)
- Secure (because it runs inside JVM)
- Multithreaded
- Backward compatibility

### Understanding the Java class structure
- Variables hold the state of the program, methods operate on that state
- Method signature is only method name + parameters
- Method declaration is method signature + modifiers + return type (+ type variables?)
- /* ...*/ is multiline comment
- /** ... */ is javadoc comment
- When multiple classes are in one file, only one can be public
- The public class in a file needs to match the filename, otherwise the file won't compile
- The main method lets the JVM call the code. It is the gateway between the code and the JVM.
- A file must have .java extension to compile
- To compile: ``` javac Zoo.java ```
- To run: ``` java Zoo ``` (no .class extension)
- if no static main method in class we execute, the JVM process will throw error and terminate.
- ```String[] args```, ```String args[]``` and ```String... args``` are okay.
- ```String [] options``` and ```String options []``` are okay too.

This code snippet compiles class Zoo and then supplies the static main function with two arguments "Bronx" and "Harlem Park". Note the quotation marks to deal with a space in Harlem Park:

```
javac Zoo.java
java Zoo Bronx "Harlem Park"
```

All command line arguments are treated as Strings. 

#### Running a program in one line:

You can do without javac if you want to compile and run a single file:
```
java Zoo.java  // with extra arguments if you want
```
This feature is called _single-file source-code_ programs, only meant when running single file. If there's a compiletime error, you get an error: compilation failed. With single-file source-code, no .class file is created, the bytecode is stored in memory. Single-file source-code can only import code from the JDK library, no other libraries.

### Understanding package declarations and imports

- Wildcard in import statement: * means all classes in a package but only on that level, not deeper, no child packages.
- Everything in java.lang doesn't need import statement, import is automatically done.
- A wildcard only matches file names, so nothing is imported if there are only packages in it.
- You can only have one wildcard and it must be at the end.
- You cannot import methods, only class names with a wildcard.
- When a class you used is found in multiple packages, compiler error.
- If you explicitly import a class name, it takes precedence over wildcard.
- Two explicit imports of classes with the same name gives compiler error.
- If you want to use two classes with the same name, use the FQN (java.sql.Date) in the code to remove ambiguity.
- You can even choose to import nothing and use FQN in your code.
- single-file source-code method works only if class/file doesn't rely on other file.

#### Compiling with wildcards

- You can use * to specify that you want to include all files in a directory: ```javac packagea/*.java```
- Such a wildcard does not include subdirectories.
- Run it by: ```java packagea.ClassWithMain```
- Compiled files are placed in the same directory as the source code by default.
- ```-d``` is the command that helps select another directory for .class files.

```javac -d compiledclasses packagea/ClassA.java packageb/*.java```

This line puts ClassA.class and all the files from packageb in a folder 'compiledclasses'. The package structure is preserved! So ClassA .class is in compiledclasses/packagea/ClassA.class.

- To run the program you need to provide the classpath -cp, -classpath or --class-path.

```
java -cp compiledclasses packagea/ClassA
```

#### Compiling with JAR files

To run a program and include files in it that are in a JAR file, do the following:

```
java -cp ".;C\temp\someFolder;C:\temp\myJar.jar" myPackage.MyClass
```

You run a program where the main function is in the main class, which is in the current directory. This is what the dot at the start is for. All other locations are in the string as well, separated by semicolons. The jar file is included as a file in this string. You can use wildcard * when there are multiple JARs in a directory that you want to include all:

```
java -cp "C:\temp\folderWithJars\*" myPackage.MyClass
```

#### Creating a JAR file

Simple form, creating jar file from all files in current directory (both work):

```
jar -cvf myNewFile.jar
jar --create --verbose --file myNewFile.jar
```

You can specify directory instead of the current one using -C:

```
jar -cvf myNewFile.jar -C somedirectory
```

#### Ordering elements in a class

- Only a class declaration is required. Class can be empty.
- Package declaration must be first line in the file (comments excluded, those can be anywhere)
- Import statements immediately after package declaration
- Class declaration immediately after import statements
- Fields and methods can be in any order, fields at the end of in middle is okay.

In the test, chack for line numbers. If there are line numbers and they start with one, check if packages and imports are alright. If not, the snippet won't compile.

</details>
<details>
<summary>Chapter 2: Java building blocks</summary>

### Creating objects

- Fields and instance initializer blocks are run in the order in which they appear in the file.
- The constructor runs only after that.


### Understanding data types

- short is signed (negative and positive numbers), char is not (only positive numbers. Both are 16 bit.
- ```long max = 3123456789 ``` gives compile error, number is larger dan Integer.MAX_VALUE 
- ```long max = 3123456789L ``` no compile error, the L communicates it is a long, not an int
- You can use underscores innumber lteral but not at start, end or next to decimal point.

### Using reference types

- Reassigning reference variable: It works when you use 'new'. Generally you need to reassign it to an object type that matches the reference type. Example:

```
String s = new String("Hello");
s = new String("Goodbye"); // correct
s = new Integer.valueOf(5); // incorrect, compile error
```

Also correct (in case of String):

```
String s = "Hello";
s = "Goodbye";
```

Also correct:
```
Integer i = Integer.valueOf(4);
Integer j = Integer.valueOf(7);
i = j; // correct
```

More example:

```
Path p = Path.of("text.txt");
p = Path.of("text2.txt");
p = Integer.valueOf(6); // incorrect, compile error
```

With primitives it is similar:

```
int t = 10;
t = 11; //okay
t = 1.3; // incorrect, t is type integer and 1.3 is type double
```

- Primitives types cannot be null, reference types can
- Reference types can be mutable or immutable. Boxed primitives and String are immutable, while most collections, StringBuilder, AtomicInteger and many others are mutable.
- Primitives do not have methods on them, reference types do.

### Identifying identifiers

- Identifiers must beging with _, $ or a letter.
- Identifiers can include numbers but cannot start with them.
- Since Java 9, a single underscore is not allowed as an identifier
- You cannot use a reserved word as an identifier. There are 54 of them, var is not aming them. Neither are Error and Exception
- This is camelCase and this is too: CamelCase. It is convention, not a rule.
- this_is_snake_case

### Declaring multiple variables

All below is alright. The first line are declarations, the second is declaration + initialization:

```
String s1, s2, s3;
String s4 = "Yes", s5 = "No", s6 = "Maybe";
```

Sneaky case:

```
int i1, i2, i3 = 0;  // correct, only i3 is initialized
String s1 = "hi", s2;  // also correct, s1 is initialized
```

This is forbidden because you cannot mix multiple variable types:

```
int num, String value;
```

This is also forbidden:

```
double d1, double d2;  // incorrect
double d1, d2; // correct
```

### Initializing variables

#### Creating local variables

- A local variable is defined within a constructor, method, or initializer block.
- Local variables do not have a default value and must be initialized before use.
- Trying to read an uninitialized local variable gives compile error.
- The compiler is smart and will detect local variables that might be read without being initialized. In that case you get compile error.
- Generally: compiler checks very well the occurence of uninitialized variables being read and gives error if this scenario is possible.

_"On the exam, be aware of any local variable that is declared but not being initialized in a single line."_

















</details>