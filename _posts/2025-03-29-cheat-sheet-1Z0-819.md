## Cheat sheet 1Z0-819

This is a new format I will try with collapsable sections. In this post I will summarize [the book](https://www.amazon.com/gp/product/B08DF4R2V9/ref=ppx_yo_dt_b_d_asin_title_351_o00?ie=UTF8&psc=1) with a lot of specific on all the topics. For now I'll follow the chapter order of the book, but it is a work in progress.

Note: these collapsables do not render well on my public page. I'll try to fix it after the test, I'm not happy with the rendering anyway.

<details>
<summary>Chapter 1: Welcome to Java</summary>

### Learning about the Java environment

- JDK contains compiler (javac), launcher (java), archiver command (jar) and API documentation (javadoc) command
- javac generates bytecode
- java launches the JVM before running the code
- JVM runs the bytecode .class files
- In Java context, API's are classes like StringBuilder that are built in and can be used

### Identifying benefits of Java
- Object oriented
- Encapsulation
- Platform independent
- Robust (garbage collection, no memory leaks)
- Simple (simpler than C++)
- Secure (because it runs inside JVM)
- Multithreaded
- Backward compatibility

### Understanding the Java class structure
- Variables hold the state of the program, methods operate on that state
- Method signature is only method name + parameters
- Method declaration is method signature + modifiers + return type (+ type variables?)
- /* ...*/ is multiline comment
- /** ... */ is javadoc comment
- When multiple classes are in one file, only one can be public
- The public class in a file needs to match the filename, otherwise the file won't compile
- The main method lets the JVM call the code. It is the gateway between the code and the JVM.
- A file must have .java extension to compile
- To compile: ``` javac Zoo.java ```
- To run: ``` java Zoo ``` (no .class extension)
- if no static main method in class we execute, the JVM process will throw error and terminate.
- ```String[] args```, ```String args[]``` and ```String... args``` are okay.
- ```String [] options``` and ```String options []``` are okay too.

This code snippet compiles class Zoo and then supplies the static main function with two arguments "Bronx" and "Harlem Park". Note the quotation marks to deal with a space in Harlem Park:

```
javac Zoo.java
java Zoo Bronx "Harlem Park"
```

All command line arguments are treated as Strings. 

#### Running a program in one line:

You can do without javac if you want to compile and run a single file:
```
java Zoo.java  // with extra arguments if you want
```
This feature is called _single-file source-code_ programs, only meant when running single file. If there's a compiletime error, you get an error: compilation failed. With single-file source-code, no .class file is created, the bytecode is stored in memory. Single-file source-code can only import code from the JDK library, no other libraries.

### Understanding package declarations and imports

- Wildcard in import statement: * means all classes in a package but only on that level, not deeper, no child packages.
- Everything in java.lang doesn't need import statement, import is automatically done.
- A wildcard only matches file names, so nothing is imported if there are only packages in it.
- You can only have one wildcard and it must be at the end.
- You cannot import methods, only class names with a wildcard.
- When a class you used is found in multiple packages, compiler error.
- If you explicitly import a class name, it takes precedence over wildcard.
- Two explicit imports of classes with the same name gives compiler error.
- If you want to use two classes with the same name, use the FQN (java.sql.Date) in the code to remove ambiguity.
- You can even choose to import nothing and use FQN in your code.
- single-file source-code method works only if class/file doesn't rely on other file.

#### Compiling with wildcards

- You can use * to specify that you want to include all files in a directory: ```javac packagea/*.java```
- Such a wildcard does not include subdirectories.
- Run it by: ```java packagea.ClassWithMain```
- Compiled files are placed in the same directory as the source code by default.
- ```-d``` is the command that helps select another directory for .class files.

```javac -d compiledclasses packagea/ClassA.java packageb/*.java```

This line puts ClassA.class and all the files from packageb in a folder 'compiledclasses'. The package structure is preserved! So ClassA .class is in compiledclasses/packagea/ClassA.class.

- To run the program you need to provide the classpath -cp, -classpath or --class-path.

```
java -cp compiledclasses packagea/ClassA
```

#### Compiling with JAR files

To run a program and include files in it that are in a JAR file, do the following:

```
java -cp ".;C\temp\someFolder;C:\temp\myJar.jar" myPackage.MyClass
```

You run a program where the main function is in the main class, which is in the current directory. This is what the dot at the start is for. All other locations are in the string as well, separated by semicolons. The jar file is included as a file in this string. You can use wildcard * when there are multiple JARs in a directory that you want to include all:

```
java -cp "C:\temp\folderWithJars\*" myPackage.MyClass
```

#### Creating a JAR file

Simple form, creating jar file from all files in current directory (both work):

```
jar -cvf myNewFile.jar
jar --create --verbose --file myNewFile.jar
```

You can specify directory instead of the current one using -C:

```
jar -cvf myNewFile.jar -C somedirectory
```

#### Ordering elements in a class

- Only a class declaration is required. Class can be empty.
- Package declaration must be first line in the file (comments excluded, those can be anywhere)
- Import statements immediately after package declaration
- Class declaration immediately after import statements
- Fields and methods can be in any order, fields at the end of in middle is okay.

In the test, chack for line numbers. If there are line numbers and they start with one, check if packages and imports are alright. If not, the snippet won't compile.

</details>
<details>
<summary>Chapter 2: Java building blocks</summary>

### Creating objects

- Fields and instance initializer blocks are run in the order in which they appear in the file.
- The constructor runs only after that.


### Understanding data types

- short is signed (negative and positive numbers), char is not (only positive numbers. Both are 16 bit.
- ```long max = 3123456789 ``` gives compile error, number is larger dan Integer.MAX_VALUE 
- ```long max = 3123456789L ``` no compile error, the L communicates it is a long, not an int
- You can use underscores innumber lteral but not at start, end or next to decimal point.
- A float requires the letter F following the number.

#### Using reference types

All the examples below refer to local variables. Instance variables cannot be reassigned in the way described below. If you want to change an instance variable, it has to be done fromout an initializer block, a constructor or a method.

- Reassigning reference variable: It works when you use 'new'. Generally you need to reassign it to an object type that matches the reference type. Example:

```
String s = new String("Hello");
s = new String("Goodbye"); // correct
s = new Integer.valueOf(5); // incorrect, compile error
```

Also correct (in case of String):

```
String s = "Hello";
s = "Goodbye";
```

Also correct:
```
Integer i = Integer.valueOf(4);
Integer j = Integer.valueOf(7);
i = j; // correct
```

More example:

```
Path p = Path.of("text.txt");
p = Path.of("text2.txt");
p = Integer.valueOf(6); // incorrect, compile error
```

With primitives it is similar:

```
int t = 10;
t = 11; //okay
t = 1.3; // incorrect, t is type integer and 1.3 is type double
```

- Primitives types cannot be null, reference types can
- Reference types can be mutable or immutable. Boxed primitives and String are immutable, while most collections, StringBuilder, AtomicInteger and many others are mutable.
- Primitives do not have methods on them, reference types do.

#### Identifying identifiers

- Identifiers must beging with _, $ or a letter.
- Identifiers can include numbers but cannot start with them.
- Since Java 9, a single underscore is not allowed as an identifier
- You cannot use a reserved word as an identifier. There are 54 of them, var is not aming them. Neither are Error and Exception
- This is camelCase and this is too: CamelCase. It is convention, not a rule.
- this_is_snake_case

#### Declaring multiple variables

All below is alright. The first line are declarations, the second is declaration + initialization:

```
String s1, s2, s3;
String s4 = "Yes", s5 = "No", s6 = "Maybe";
```

Sneaky case:

```
int i1, i2, i3 = 0;  // correct, only i3 is initialized
String s1 = "hi", s2;  // also correct, s1 is initialized
```

This is forbidden because you cannot mix multiple variable types:

```
int num, String value;
```

This is also forbidden:

```
double d1, double d2;  // incorrect
double d1, d2; // correct
```

### Initializing variables

#### Creating local variables

- A local variable is defined within a constructor, method, or initializer block.
- Local variables do not have a default value and must be initialized before use.
- Trying to read an uninitialized local variable gives compile error.
- The compiler is smart and will detect local variables that might be read without being initialized. In that case you get compile error.
- Generally: compiler checks very well the occurence of uninitialized variables being read and gives error if this scenario is possible.

_"On the exam, be aware of any local variable that is declared but not being initialized in a single line."_

#### Passing constructor and method parameters

These parameters must be initialized before the method is called, obviously.

#### Defining instance and class variables

- Class variable is another word for static variable (at class level).
- Instance and class variables are given a default value on declaration. This is different from local variables. 
- Defaults of numbers is 0 or 0.0, of boolean is false, of reference types is null.

#### Introducing var

- ```var``` can only be used in local context, not for instance or class variables! (I didn't know that). You can use it as well in initializer blocks and constructors.

_"Local variable type inference works with local variables and not instance variables."_

#### Type inference of var / examples with var

- Compiler figures out the type of var. After that you cannot assign another type to it, but you can change the value.
- You might say that var behaves exactly like any specific type.
- If compiler can't figure out the type during declaration, compile error. 
- Using var thus only works if declaration and initialization happens at the same time.
- Java doesn't allow var in multiple type declarations like these: ```var a=3, b=2```
- ```var n = null``` is not allowed. Type can be any reference type.
- ```var k = (String) null``` is allowed. Compiler can infer the type.

_"Be on the lookout for var used with constructors, method parameters, or instance variables."_

_"Remember that var is only used for local variable type inference!"_

```var``` is not a reserved word, you can use it as identifier. But it is a _reserved type name_, which means you cannot use is as the name of a class, enum or interface.

Summary:
- A var is used as a local variable in a constructor, method or initializer block.
- A var cannot be used in constructor parameters, method parameters, instance variables, or class variables.
- A var is always initialized on the same line (or statement) where it is declared.
- The value of a var can change but the type cannot.
- A var cannot be initialized with a null value without a type.
- A var is no permitted in a multiple-variable declaration.
- A var is a reserved type name but not a reserved word, meaning it can be used as identifier but not as the name of a class, enum or interface.

### Managing variable scope

Method parameters count as local variables. They have the same scope as local variables within the class and are removed by the gc in the same way.

Each block ({}) has its own scope.

Within a method you can reference variables that are outside your {} scope, but they cannot reference you.

_"Identifying blocks and variable scope needs to be second nature for the exam._"

#### Reviewing scope

- Local variables: in scope from declaration to end of block.
- Instance variables: in scope from declaration until object eligible for garbage collection.
- Class variables: in scope from declaration until program ends.

### Destroying objects

#### Eligible for garbage collection

All Java objects are stored in the _heap_, also called the _free store_.

Eligible for garbage collection refers to an object's state of no longer being accessible in aprogram and therefore able to be garbage collected.

```System.gc()``` is a method that _suggest_ that the JVM start with garbage collection. But you can't force the JVM, so it might as well not happen anyway. The JVM is free to ignore the request.

#### Tracing eligibility

An object will remain on the heap until it is no longer reachable. It is no longer reachable when one of two situations occur:

- The object no longer has any references pointing to it
- All refernces to the object have gone out of scope























</details>