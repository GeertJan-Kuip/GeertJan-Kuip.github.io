## Cheat sheet 1Z0-819

This is a new format I will try with collapsable sections. In this post I will summarize [the book](https://www.amazon.com/gp/product/B08DF4R2V9/ref=ppx_yo_dt_b_d_asin_title_351_o00?ie=UTF8&psc=1) with a lot of specific on all the topics. For now I'll follow the chapter order of the book, but it is a work in progress.

Note: these collapsables do not render well on my public page. I'll try to fix it after the test, I'm not happy with the rendering anyway.

<details>
<summary>Chapter 1: Welcome to Java</summary>


### Learning about the Java environment

- JDK contains compiler (javac), launcher (java), archiver command (jar) and API documentation (javadoc) command
- javac generates bytecode
- java launches the JVM before running the code
- JVM runs the bytecode .class files
- In Java context, API's are classes like StringBuilder that are built in and can be used

### Identifying benefits of Java
- Object oriented
- Encapsulation
- Platform independent
- Robust (garbage collection, no memory leaks)
- Simple (simpler than C++)
- Secure (because it runs inside JVM)
- Multithreaded
- Backward compatibility

### Understanding the Java class structure

- Variables hold the state of the program, methods operate on that state
- Method signature is only method name + parameters
- Method declaration is method signature + modifiers + return type (+ type variables?)
- /* ...*/ is multiline comment
- /** ... */ is javadoc comment
- When multiple classes are in one file, only one can be public
- The public class in a file needs to match the filename, otherwise the file won't compile
- The main method lets the JVM call the code. It is the gateway between the code and the JVM.
- A file must have .java extension to compile
- To compile: ``` javac Zoo.java ```
- To run: ``` java Zoo ``` (no .class extension)
- if no static main method in class we execute, the JVM process will throw error and terminate.
- ```String[] args```, ```String args[]``` and ```String... args``` are okay.
- ```String [] options``` and ```String options []``` are okay too.

This code snippet compiles class Zoo and then supplies the static main function with two arguments "Bronx" and "Harlem Park". Note the quotation marks to deal with a space in Harlem Park:

```
javac Zoo.java
java Zoo Bronx "Harlem Park"
```

All command line arguments are treated as Strings. 

#### Running a program in one line:

You can do without javac if you want to compile and run a single file:
```
java Zoo.java  // with extra arguments if you want
```
This feature is called _single-file source-code_ programs, only meant when running single file. If there's a compiletime error, you get an error: compilation failed. With single-file source-code, no .class file is created, the bytecode is stored in memory. Single-file source-code can only import code from the JDK library, no other libraries.

### Understanding package declarations and imports

- Wildcard in import statement: * means all classes in a package but only on that level, not deeper, no child packages.
- Everything in java.lang doesn't need import statement, import is automatically done.
- A wildcard only matches file names, so nothing is imported if there are only packages in it.
- You can only have one wildcard and it must be at the end.
- You cannot import methods, only class names with a wildcard.
- When a class you used is found in multiple packages, compiler error.
- If you explicitly import a class name, it takes precedence over wildcard.
- Two explicit imports of classes with the same name gives compiler error.
- If you want to use two classes with the same name, use the FQN (java.sql.Date) in the code to remove ambiguity.
- You can even choose to import nothing and use FQN in your code.
- single-file source-code method works only if class/file doesn't rely on other file.

#### Compiling with wildcards

- You can use * to specify that you want to include all files in a directory: ```javac packagea/*.java```
- Such a wildcard does not include subdirectories.
- Run it by: ```java packagea.ClassWithMain```
- Compiled files are placed in the same directory as the source code by default.
- ```-d``` is the command that helps select another directory for .class files.

```javac -d compiledclasses packagea/ClassA.java packageb/*.java```

This line puts ClassA.class and all the files from packageb in a folder 'compiledclasses'. The package structure is preserved! So ClassA .class is in compiledclasses/packagea/ClassA.class.

- To run the program you need to provide the classpath -cp, -classpath or --class-path.

```
java -cp compiledclasses packagea/ClassA
```

#### Compiling with JAR files

To run a program and include files in it that are in a JAR file, do the following:

```
java -cp ".;C\temp\someFolder;C:\temp\myJar.jar" myPackage.MyClass
```

You run a program where the main function is in the main class, which is in the current directory. This is what the dot at the start is for. All other locations are in the string as well, separated by semicolons. The jar file is included as a file in this string. You can use wildcard * when there are multiple JARs in a directory that you want to include all:

```
java -cp "C:\temp\folderWithJars\*" myPackage.MyClass
```

#### Creating a JAR file

Simple form, creating jar file from all files in current directory (both work):

```
jar -cvf myNewFile.jar
jar --create --verbose --file myNewFile.jar
```

You can specify directory instead of the current one using -C:

```
jar -cvf myNewFile.jar -C somedirectory
```

#### Ordering elements in a class

- Only a class declaration is required. Class can be empty.
- Package declaration must be first line in the file (comments excluded, those can be anywhere)
- Import statements immediately after package declaration
- Class declaration immediately after import statements
- Fields and methods can be in any order, fields at the end of in middle is okay.

In the test, chack for line numbers. If there are line numbers and they start with one, check if packages and imports are alright. If not, the snippet won't compile.

</details>

<details>
<summary>Chapter 2: Java building blocks</summary>

### Creating objects

- Fields and instance initializer blocks are run in the order in which they appear in the file.
- The constructor runs only after that.


### Understanding data types

- short is signed (negative and positive numbers), char is not (only positive numbers. Both are 16 bit.
- ```long max = 3123456789 ``` gives compile error, number is larger dan Integer.MAX_VALUE 
- ```long max = 3123456789L ``` no compile error, the L communicates it is a long, not an int
- You can use underscores innumber lteral but not at start, end or next to decimal point.
- A float requires the letter F as prefix to the number, but only if there is a decimal point in it. 
- A decimal number without F (or f) is seen by default as a double.

_You can be tricked, watch out for missing F with float initialization! Check if the value can be misunderstood as a double._

#### Using reference types

All the examples below refer to local variables. Instance variables cannot be reassigned in the way described below. If you want to change an instance variable, it has to be done fromout an initializer block, a constructor or a method.

- Reassigning reference variable: It works when you use 'new'. Generally you need to reassign it to an object type that matches the reference type. Example:

```
String s = new String("Hello");
s = new String("Goodbye"); // correct
s = new Integer.valueOf(5); // incorrect, compile error
```

Also correct (in case of String):

```
String s = "Hello";
s = "Goodbye";
```

Also correct:
```
Integer i = Integer.valueOf(4);
Integer j = Integer.valueOf(7);
i = j; // correct
```

More example:

```
Path p = Path.of("text.txt");
p = Path.of("text2.txt");
p = Integer.valueOf(6); // incorrect, compile error
```

With primitives it is similar:

```
int t = 10;
t = 11; //okay
t = 1.3; // incorrect, t is type integer and 1.3 is type double
```

- Primitives types cannot be null, reference types can
- Reference types can be mutable or immutable. Boxed primitives and String are immutable, while most collections, StringBuilder, AtomicInteger and many others are mutable.
- Primitives do not have methods on them, reference types do.

#### Identifying identifiers

- Identifiers must beging with _, $ or a letter.
- Identifiers can include numbers but cannot start with them.
- Since Java 9, a single underscore is not allowed as an identifier
- You cannot use a reserved word as an identifier. There are 54 of them, var is not aming them. Neither are Error and Exception
- This is camelCase and this is too: CamelCase. It is convention, not a rule.
- this_is_snake_case

#### Declaring multiple variables

All below is alright. The first line are declarations, the second is declaration + initialization:

```
String s1, s2, s3;
String s4 = "Yes", s5 = "No", s6 = "Maybe";
```

Sneaky case:

```
int i1, i2, i3 = 0;  // correct, only i3 is initialized
String s1 = "hi", s2;  // also correct, s1 is initialized
```

This is forbidden because you cannot mix multiple variable types:

```
int num, String value;
```

This is also forbidden:

```
double d1, double d2;  // incorrect
double d1, d2; // correct
```

### Initializing variables

#### Creating local variables

- A local variable is defined within a constructor, method, or initializer block.
- Local variables do not have a default value and must be initialized before use.
- Trying to read an uninitialized local variable gives compile error.
- The compiler is smart and will detect local variables that might be read without being initialized. In that case you get compile error.
- Generally: compiler checks very well the occurence of uninitialized variables being read and gives error if this scenario is possible.

_"On the exam, be aware of any local variable that is declared but not being initialized in a single line."_

#### Passing constructor and method parameters

These parameters must be initialized before the method is called, obviously.

#### Defining instance and class variables

- Class variable is another word for static variable (at class level).
- Instance and class variables are given a default value on declaration. This is different from local variables. 
- Defaults of numbers is 0 or 0.0, of boolean is false, of reference types is null.

#### Introducing var

- ```var``` can only be used in local context, not for instance or class variables! (I didn't know that). You can use it as well in initializer blocks and constructors.

_"Local variable type inference works with local variables and not instance variables."_

#### Type inference of var / examples with var

- Compiler figures out the type of var. After that you cannot assign another type to it, but you can change the value.
- You might say that var behaves exactly like any specific type.
- If compiler can't figure out the type during declaration, compile error. 
- Using var thus only works if declaration and initialization happens at the same time.
- Java doesn't allow var in multiple type declarations like these: ```var a=3, b=2```
- ```var n = null``` is not allowed. Type can be any reference type.
- ```var k = (String) null``` is allowed. Compiler can infer the type.

_"Be on the lookout for var used with constructors, method parameters, or instance variables."_

_"Remember that var is only used for local variable type inference!"_

```var``` is not a reserved word, you can use it as identifier. But it is a _reserved type name_, which means you cannot use is as the name of a class, enum or interface.

Summary:
- A var is used as a local variable in a constructor, method or initializer block.
- A var cannot be used in constructor parameters, method parameters, instance variables, or class variables.
- A var is always initialized on the same line (or statement) where it is declared.
- The value of a var can change but the type cannot.
- A var cannot be initialized with a null value without a type.
- A var is no permitted in a multiple-variable declaration.
- A var is a reserved type name but not a reserved word, meaning it can be used as identifier but not as the name of a class, enum or interface.

### Managing variable scope

Method parameters count as local variables. They have the same scope as local variables within the class and are removed by the gc in the same way.

Each block ({}) has its own scope.

Within a method you can reference variables that are outside your {} scope, but they cannot reference you.

_"Identifying blocks and variable scope needs to be second nature for the exam._"

#### Reviewing scope

- Local variables: in scope from declaration to end of block.
- Instance variables: in scope from declaration until object eligible for garbage collection.
- Class variables: in scope from declaration until program ends.

### Destroying objects

#### Eligible for garbage collection

All Java objects are stored in the _heap_, also called the _free store_.

Eligible for garbage collection refers to an object's state of no longer being accessible in aprogram and therefore able to be garbage collected.

```System.gc()``` is a method that _suggest_ that the JVM start with garbage collection. But you can't force the JVM, so it might as well not happen anyway. The JVM is free to ignore the request.

#### Tracing eligibility

An object will remain on the heap until it is no longer reachable. It is no longer reachable when one of two situations occur:

- The object no longer has any references pointing to it
- All refernces to the object have gone out of scope

</details>

<details>
<summary>Chapter 3: Operators</summary>

### Understanding Java operators

#### Types of operators

#### Operator precedence

|Symbols and examples|
|--------------|
|_expr++ , expr--_|
|_++expr , --expr_|
|_- , ! , ~ , + , **(type)**_|
|_* , / , %_|
|_+ , -_|
|_<< , >> , >>>_|
|_< , > , <= , >= , **instanceof**_|
|_== , !=_|
|_& , ^, \|_|
|_&& , \|\|_|
|_ternary operator_|
|_all assignment operators_|

### Applying unary operators

A unary is one that requires exactly one operand, or variable, to function. They are ```! , + , - , ++ , -- , (type)```

#### Logical complement and negation operators

_"Beware that in Java, 1 and true or 0 and false are not interchangeable or related."_

#### Increment and decrement operators

The pre-decrement or pre-increment operator (--expr or ++ expr) returns the new value, the post-decrement and post-increment operators return the old value.

Code sample (be aware that post-increment/decrement has precedence on pre-increment/decrement):

```
int lion = 3;
int tiger = ++lion*5/lion--; // 3*5/3 as post-increment goes first
System.out.println(lion);  // 3
System.out.println(tiger);  // 5
```

### Working with binary arithmetic operators

They need two values to operate on instead of (unary) one.

#### Arithmetic operators 

Binary arithmetic operators are +,-,*,/,%

#### Numeric promotion

The rules below are foolowed when applying operators to data types:

- If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.
- If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value's data type.
- Smaller data types, namely byte, short and char, are first promoted to int any time they're used with a Java binary arithmetic operator, even if neither of the operands is int.
- After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.

For the third rule, note that unary operators are excluded from this rule. short++ is still a short.

### Assigning values

#### Casting values

These do not compile

```
float egg = 2.0 / 9;  // 2.0 is a double, so result is a double
int a = (int)5 * 2L;  // 2L is a long, so result is a long
short frog = 3 - 2.0;  // 2.0 is a long, so result is a long
```

```
short bird  = 1921222; // does not compile, value is out of range
long x = 912301398193810323; // does not compile but it would if L was added.
			      // Java interprets the literal as an int and can't cope.
```

#### Applying casting

Downcasting is often possible:

```
int trainer = (int)1.0; // stored as 1;
short a = (short)1921222; // stored as 20678
int u = (int)gf;
long m = 912301398193810323L;
```

_"Remember, casting primitives is required any time you are going from a larger numerical data type to a smaller numerical data type, or converting from a floating-point number to an integral value."_

Underflow and underflow (not in exam): when downcasting, for example from int to short, a sort of modulo may be applied. See the 'short a' example above.

#### Compound assignment operators

``` += , -= , *= , /= ```

These operators help to avoid a cast. Example:

```
long goat = 10;
int sheep = 5;
sheep = sheep * goat; // doesn't compile
sheep *= goat; // compiles. Sheep will first be cast to long, only then the multiplication is done
```

#### Assignment operator return value

Something new: an assignment is in itself an expression that returns a value. 

```
long w = 5;
long c = (w=3);
System.out.println(w);  // 3
System.out.println(c);  // 3
```

_The return value of the assignment is the value to which the left part of the assignment is set!_

Another example:

```
boolean healthy = false;
if(healthy=true)
    System.out.println("Good!");
```

While I would say this was a mistake and == was required, ```(healthy=true)``` actually returns ```true```.

### Comparing values

The ```==``` operator, applied to primitives, looks if the values are the same. When applied to objects, it sees if the two values reference the same object.

With primitives, the == returns true if the numeric values are the same, even if they are of different type (say float and int).

Equality operators (== and !=) can be used in the following three scenarios:
- Comparing two numeric or character primitives. Values are automatically promoted if not of the same type.
- Comparing two boolean values
- Comparing two objects, including null and String values.

Types cannot be mixed outside of these three cases, otherwise compile error. The following lines do not compile:

```
boolean a = true==3;
boolean b = false!="Grape";
boolean c = 10.2=="Hank";
```

_"Pay close attention to the data types when you see an equality operator on the exam. ...The exam creators also have a habit of mixing assignment operators and equality operators."_

Below an example where ```==``` returns false, even though both reference variables point to the same object:

```
File a = new File("text.txt");
File b = new File("text.txt");
File c = b;
a == b; // false
b==c; // true
```

Because b created a new object, a and b are not equal with regards to ==.

#### _instanceof_ operator

Using instanceof on two unrelated variable types gives compile error.

_"For the exam, you should know that calling instanceof on the null literal or a null reference always returns false."_

Furthermore,  ```null instanceof null``` does not compile.

#### Logical operators

- AND ```&``` is only true if both operands are true
- Inclusive OR ```|``` is only false if both operands are false
- Exclusive OR ```^``` is only true if the operands are different

#### Short-circuit operators

```&& , ||```

_Important: other dan with the logical operators, here the right side of the expression may never be evaluated if the final result can be determined by the left side of the expression._

&& and || works from left to right, while &,|,^ have no defined order. Example:

```
int hour = 10;
boolean zooOpen = true || (hour<4); // right side is never evaluated
System.out.println(zooOpen); // true
```

This principle can be used to avoid NullPointerException:

```
if(x!=null && x.getAge()<5){  // x.getAge() is not executed if x==null
    doSomething();
}
```

_"Be wary of short-circuit behavior on the exam, as questions are known to alter a variable on the right side of the expression that may never be reached."_

### Making decisions with the ternary operator

Second and third expression do not have to be the same data types, although in an assignment this must be the case. If a ternary can return a value of the wrong type, code won't compile: 

```
int animal - (stripes>9) ? 3 : "Horse"; // doesn't compile
```

Like with short-circuit operators, the third expression is not evaluated if the first expression is true. 

_"Be wary of any question that includes a ternary expression in which a variable is modified in one of the right-hand side expressions."_

</details>




<details>
<summary>Chapter 4: Making decisions</summary>

### Creating decision-making statements

#### Statements and blocks

A statement is a complete unit of execution in Java, terminated with a semicolon.

A block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.

#### The _if_ statement

_"One area where the exam writers will try to trip you up is on if statements without braces ({})."_

#### The _else_ statement

If a specific else statement cannot be reached, because an earlier statement already covers the case, the code will compile anyway.

_"Another common place the exam may try to lead you astray is by providing code where the boolean expression inside the if statement is not actually a boolean expression."_

#### The switch statement

- Beware of parentheses (mandatory)
- Use ```switch(someVar) {}```, not ```switch someVar {}```
- Each case statement requires the keyword case, followed by a value and a colon.
- This is allowed: ```case 1: case 2: ```
- This is allowed: ```switch(someVar){}```

The following datatypes are allowed for switch:
- int, byte, short, char, Integer, Byte, Short, Character, enum, String
- var is allowed if it resolves to one of those types

Note: Java 12 introduced more possibilities with switch, based on lambda's, but these are not in the exam.

The default statement can be anywhere, doesn't need to be at the end. Order can be important anyway if break statements are omitted. Say, the value sought after is not among the case statements, then it goes to default, and if default has no break, it will trickle down from there on. So if default is not at the end, at least add a break statement to it.

The default block is only executed if no other value matches, regardsless of the order.

_"The exam creators are fond of switch examples that are missing break statements!"_

Case statements need values that are any of these:
- a final constant variable (initialized with a literal value in the same expression in which it was declared)
- an enum constant
- an expression of literals (3*2)
- an expression of finals
- a literal

In general, the value must be resolved at compile time, so a value that is the result of a method running at runtime is not allowed. Furthermore, it must match the type in the switch statement (of course).

#### Numeric promotion and casting

Switch statements support numeric promotion that does not require an explicit cast. For example, If the switch expression is a short and the case an int, it will work unless the int is bigger than max short size.

### Writing _while_ loops

There is _while_ and _do/while_. In both while always has an () containing the condition. 

A while block can do without {} if there is just one statement. The following is alright.

```
int q = 1;
while (q<5)
    System.out.println(q++);
````

#### Infinite loops

Be aware that a loop should terminate somewhere.

### Constructing _for_ loops

Variables declared in the initialization block have limited scope and are only accessible in the loop. The initialization block is the first part of the for statement, before the first semicolon.

Each component of the initialization block is optional. The semicolons are mandatory, there must be two. Below is a valid infinite loop: 

```
for (;;)  
    // some code
```` 

You can add multiple terms in the for statement:

```
int x = 0;
for(long y=0, z=4; x<5 && y<10; x++, y++){  // it is important that y and z have the same type.
    System.out.println(y + "");
}
System.out.println(x + "");
```

You cannot redeclare a variable in the initialization block:

```
int x = 0;
for (int x=4; x<5;x++)   // does NOT compile
    System.out.println(x + "");   
```

But this is alright:

```
int x = 0;
for (x=4; x<5;x++)   // does compile
    System.out.println(x + "");   
```

Variables in the initialization block need to be of the same type. The following does not work for that reason:

```
int x=0;
for (long y=0, int z=4; x<5;x++){} // does not compile
```

Java allows modification of loop variables, although it is mostly bad practice. The enhanced loop is a different thing btw.

#### The for-each loop

Also called the enhanced for-loop, meant to iterate over collections. Two types can be iterated with for-each:
- A built-in Java array
- An object whose type implements java.lang.Iterable

Map doesn't implement iterable, neither do String and StringBuilder.

The for-each loop accepts var for the loop variable, just like the regular for loop.

### Controlling flow with branching

#### Nested loops

Beware not to take too much time on the exam figuring out complex nested loops.

#### Adding optional labels

If statements, switch statements and loops can all have optional labels. All code below is valid:

```
OUTER_LOOP: for (String s : list){
    // code
};
```
```
int x = 5;

MY_SWITCH: switch(x){
    case 5:
        System.out.println("Yes!");
        break;
    default:
        break;
}
```
```
A: for (int i=0; i<5; i++)
    B: for (int j=0; j<3; j++)
        System.out.printf("i=%s and j=%s\n", i,j);
```
```
MY_LABEL: System.out.println("Hi"); // this is also okay
````

The compiler is very relaxed about using optional labels. The only rule is that it needs to be followed by a statement, although assignments are not permitted. ```MY_LABEL: Integer a = 2;``` doesn't compile for that reason.

#### The _break_statement

Break statements are not limited to switch, you can put them in while, do/while and in for loop. In all cases it will end things early.

If you have added labels to your for loop(s), you can use them with the break statement like ```break PARENT_LOOP;```. By doing so you will break out of the parent loop, which might be one level higher than the child loop you would normally break out of.

This helps to avoid unnecessary continuation of a nested loop so it is handy.

#### The _continue_ statement

While the break statement breaks out of the loop entirely, the contue statement only breaks out of the current iteration. If i was 3, it will skip to i=4. You can use continue with optional label to alter the result:

```
CLEANING: for (char c='a'; c<'d'; c++){
    for (int i=1; 1<4; i++){
        if(c=='b' || i==2){
            continue CLEANING;
        }
        System.out.println(c + " " + i)
    }
]

//output:
a 1
c 1
d 1
```

The special thing is that ```continue CLEANING;``` skips all the inner i iterations and goes to the next outer c iteration right away.

#### The _return_ statement

Return breaks out of the loop and returns a value. Their benefit is that they provide more readable code.

#### Unreachable code

When break, continue or return are wrongly positioned that can cause parts of the code to be unreachable. If this is the case you get a compiler error. Think of:

```
case 6:
    break;
    someMethod();  // unreachable, compile error
```

#### Reviewing branching

There are 4 flow controls. Book provides a table with their relationships to optional labels, break and continue:

||**Allows optional lables**|**Allows _break_ statement**|**Allows _continue_ statement**|
|----|----|----|----|
|while|Yes|Yes|Yes|
|do while|Yes|Yes|Yes|
|for|Yes|Yes|Yes|
|switch|Yes|Yes|No|

Summary: switch does not allow _continue_ statement.

</details>



<details>
<summary>Chapter 5: Core Java APIs</summary>

### Creating and manipulating strings

#### Concatenation

Beware that adding strings and numbers happens from left to right. The following outputs "3c":

```
System.out.println(1 + 2 + "c"); // 3c
```

#### Important _String_ methods

- _int length()_
- _char charAt(int index)_
- _int indexOf()_
- _String substring(int beginindex)_
- _String substring(int beginIndex, int endIndex)_
- _String toLowerCase()_
- _String toUpperCase()_
- _boolean equals(Object obj)_
- _boolean equalsIgnoreCase(String str)_
- _boolean startsWith(String prefix)_
- _boolean endsWith(String suffix)_
- _String replace(char oldChar, char newChar)_
- _String replace(CharSequence target, CharSequence replacement)_
- _boolean contains(CharSequence charSeq)_
- _String strip()_
- _String stripLeading()_
- _String stripTrailing()_
- _String trim()_
- _String intern()_

strip() does everything what trim()  does but supports Unicode.

### Using the StringBuilder class

Modifying a string multiple times results in the creation of multiple new objects which is not efficient. This is what StringBuilder is for, it is a mutable type.

When StringBuilder returns itself, it is not a copy of itself but just a reference to the same object. This is different from String, where a new String object is returned. 

#### Creating a StringBuilder

Three ways:

```
StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);
```

#### Important StringBuilder methods

_**charAt(int index), indexOf(String str), length(), subString(int start, int end)**_

Important: subString() returns a String, not a StringBuilder. subString() has a one parameter variant as well with only the start position.

- StringBuilder _**append(String str)**_ 
- StringBuilder _**insert(int offset, String str)**_ 
- StringBuilder _**delete(int startindex, int endindex)**_ 
- StringBuilder _**deleteCharAt(int index)**_ 

The latter is convenient if you want to delete just one character.

_StringBuilder **replace(int start, int end, String newString)**_

This one removes positions start to end and inserts the third String parameter.

_StringBuilder **reverse()**_

_String **toString()**_

These two speak for themselves.

### Understanding equality

Using ```==``` on StringBuilder checks if the variables refer to the same object. 
StringBuilder hasn't implemented ```equals()```, so calling equals returns the same as calling ```==``` (variables referencing the same object).

With String this is different. String has implemented equals to check for the equality of the String content. If you want to check of two StringBuilder variables are referring to StringBuilder instances with the same content, you need to convert them to Strings and compare the strings.

The following does not compile because you cannot use ```==``` on different types.

```
String string = "a";
StringBuilder builder =  new StringBuilder("a");
System.out.println(string==builder); // does not compile
```

### The _String_ pool

Strings with the same content are stored as one object in the String pool, but you can avoid this by using new String(..). Also when a String is computed at runtime, it will be stored as a new String even if there is already an identical one in the String pool.

_If one String is computed at compile time and the other at runtime, ```==``` will always return false._

You can force Java to use the String pool when creating a new String using inter():

```
String name = "Hello World";
String name2 = new String("Hello World").intern();
System.out.println(name==name2); // TRUE
```

### Understanding Java arrays

```int[] numbers = new int[] {1,2,3};``` and ```int[] numbers = {1,2,3};``` are both okay.

```int a[], b;``` creates an int array (a[]) and an int (b).

As String[] is an object, it can be used in castings. Like ```String[] a = (String[]) objects```. It works if objects is indeed an array of Strings.

Note that you can store different types in an array Object[], but that this will give a runtime error ArrayStoreException.

If you initialize an arry like ```String[] b = new String[6]```, this new array will have a length of 6 whereby each value is null.

#### Searching

You can search for an element in a Java array but the results are only meaningful when the array is sorted (Arrays.sort(myArray)). 

If the value is not found, you might find a negative number. The rule for this negative number is:
- Check the position where the value you search for would be posiitioned if it was in there (the array is sorted so you can do this)
- Make this number negative and subtract 1. This is the result of Arrays.binarySearch(). 

Example:

```
int[] numbers = {2,4,6,8};
System.out.println(Arrays.binarySearch(numbers, 2)); // 0
System.out.println(Arrays.binarySearch(numbers, 5)); // -3
```

The second line gives -3 as 5 would be on position 2, make -2, subtract 1.

If the array is not sorted, the output will be kind of unpredictable.

#### Comparing

The Arrays class has a compare(array1, array2) method. Interpretation of the result is as follows:
- A negative number means the first array is smaller than the second
- Zero means that they are equal
- A positive number means the first array is larger than the second

Note: this is the same pattern as for Comparator.

How does Java decide which array is larger?
- If arrays are identical, same size and same values at same places, compare returns 0.
- If they are the same but one has extra values at the end, that one is larger.
- You can put them next to each other and compare values until one of the arrays has a larger value than the other on that place. Then that array is the larger one.

General larger/smaller rules:
- null is smaller than any other value
- for numbers, just order them.
- for strings, one is smaller if it is a prefix of the other
- for strings/characters, numbers are smaller than letters
- for strings/characters, uppercase is smaller than lowercase

When comparing two arrays, they must be of the same type, if not, compile error.

_**Arrays.mismatch(array1, array2)**_

I had not heard of this one. Returns -1 if arrays the same, if the arrays are not the same, it returns the index where the first difference is found.

_Definition of mismatch(): finds and returns the index of the first mismatch of two int arrays, or -1 if they are identical._

Note: also works with other primitives, and also with String. Might be convenient when comparing two datasets to see where they differ.

#### Multidimensional arrays

You can be very creative when declaring a multidimensional array. The [] can be on all the places where you can put them in a onedimensional array. A nice one:

```
int[] a[], b[][]; // creates a 2D and a 3D array
```

The arrays in the array can be of different size. This is okay:

```
int[][] arr = {{1,4}, {3}, {5,6,7,8}};
```

You can go in steps:

```
int[][] a = new int[5][];
a[0] = new int[3];
a[1] = new int[7];
```

### Understanding an ArrayList

Funny, this compiles: 

```
var list = new ArrayList<>(); // arraylist of type Object
```

It is still possible to create ArrayLists without type and put 'Objects' in it. It has to do with backward compatibility.

This paragraph mentions the methods for (Array)List but they are in chapter 12 as well.

The equals() method for ArrayList only returns true if the ArrayLists are identical.

#### Wrapper classes

Each primitive has a wrapper class and you can create a wrapped primitive by the .valueOf() method (Double.valueOf(1.0), Float.valueOf((float) 1.0), Byte.valueOf((byte) 1)) etc.).

**Important:** The wrapper classes are immutable.

Conversion methods you need to know for the exam:

```
int p = Integer.parsInt("123");
Integer w = Integer.valueOf("123"';

int b = Integer.parseInt("a"); // throws NumberFormatException
Integer c = Integer.valueOf("12.67"); // throws NumberFormatException
```

Remarkable: many static methods in the Integer class return int primitive. ParseInt() is only one of them.

_Generally speaking, every primitive wrapper class has a custom .parse method (.parseBoolean, .parseShort etc) to convert a String to a primitive, and a .valueOf method to convert a String to the wrapper class type._

#### Converting between array and list

```list.toArray()``` converts List to Array.
```List.of(array)``` converts Array to immutable list
```Arrays.asList(array)``` converts Array to fixed size List

The List returned by Arrays.asList is a List backed by the array it is created from. Changes in one of them changes the other as well, they are connected. They point to the same store.

### Creating sets and maps

I refer to chapter 12.

### Calculating with Math APIs

_**min()**_ and _**max()**_

These two return either the highest or lowest of two values

_**round()**_

Gets rid of the decimal portion, if .5 or higher it chooses the higher number.

_**pow()**_

Method signature is _double pow(double number, double exponent)_.

_**random()**_

Returns a double between 0 and 1.0. Can be 0 but not 1.

</details>

<details>
<summary>Chapter 6: Lambdas and functional interfaces</summary>


I skip a lot, have written about it elsewhere and experimented with it. It will be in Chapter 15 as well.

### Introducing functional interfaces

A functional interface has **exactly one** abstract method. The methods inherited from object do not count in this total.

#### Comparator

Both these lines sort in descending order (note the - in the second line)

```
Comparator<String> strings1 = (s1,s2) -> s2.compareTo(s1);
Comparator<String> strings2 = (s1,s2) -> - s1.compareTo(s2);
```

### Working with variables in lambdas

What is the type of x? I included this one because I have trouble reading methods with a functional interface as parameter. I need to learn to recognize the pattern. Generally, an aggregate method with a FI and a value as parameter are testing the value using the FI.

```
public void whatAmI(){
    consume((var x) -> System.out.println(x), 123);
}

public void consume(Consumer<Integer> c, int num){
    c.accept(num);
}
```

#### Local variables in the lambda body

Example with three compile errors (and I missed them all):

```
public void variables(int a){
    int b = 1;
    Predicate<Integer> p1 = a -> {   // a is already used as parameter in the method. Cannot reuse
        int b = 0;       // b is already declared in the method. Cannot do again.
        int c = 0;
        return b==c;}     // a semicolon after the block is required here. The lambda is an 
                          // expression, not a statement
}
```

_Generally: there are naming conflicts if, in a lambda, you reuse variable names that exist somewhere else in the method, including the parameters._

_**More generally: within methods, variables in nested blocks cannot shadow those in outer blocks. This is extremely important.**_

_**Lambda parameters/local variables must not conflict with the enclosing method's scope.**_

The only time you can reuse variables is with nested sibling blocks:

```
void myMethod(){
    {int a = 10;}
    {int a = 20;}
}
```

#### Variables referenced from the lambda body

- Lambdas (in methods) can always access instance- and class variables
- Method parameters and local variables can only be accessed if they are **effectively final**.

It is not a problem to assign a new value to a local variable. It is just important to know that when you do that, it is not effectively final anymore and cannot be used in a lambda. It doesn't matter where in the method the reassignment takes place.

</details>



<details>
<summary>Chapter 7: Methods and encapsulation</summary>

### Designing methods

A method declaration has the following structure:

_acces modifier - optional specifier - return type - method name - list of parameters - exception (optional)_

#### Optional specifiers

The optional specifiers are:
- static
- abstract
- final
- synchronized
- native
- strictfp

#### Return type

A void method can do return; (without returning a value).

### Applying the _static_ keyword

To call a static method, you can either do _ClassName.staticMethodName()_ or _variableName.staticMethodName()_. For the latter, you only have to look for the variable type. The following compiles:

```
Koala k = new Koala();
System.out.println(k.count); // let count be a static variable
k = null;
System.out.println(k.count); // you get the same result. It is about the type of the variable, which is still Koala. It would not work if count was an instance variable.
```

_And remember, don't call instance variables or methods fromout static methods without referencing an instance of the class._

#### Static variables

The following code compiles, because even as the variable is final, it is a reference variable. It is okay to call methods on reference variables, what is not allowed is to point a reference variable to another object if the variable is final.

```
private static final ArrayList<String> values = new ArrayList<>();
public static void main(String[] args) {
    values.add("changed");
}
```

The declaration and initialization of a _final_ static variable does not have to happen in the same statement. You can declare them first and later initialize them _in a static initializer_. This is okay since a static initializer will at most execute once.

If you declare a _final_ static variable (class variable) without initializing it in a static initializer, you will get compile error.

If the static variable is not final, it is okay to declare it without initializing it in the initializer. Compiler won't protest. Code below compiles.

```
static int kl;
final static int bg;
static{ bg =6;} // without this, compile error on the line above
```

#### Static imports

Static imports are for importing static members of classes. It is convenient when you use certain methods often, you can omit the classname then. 

This is how you do a static import:

```
import static java.util.Arrays.asList; // one static member
import static java.util.Arrays.*; // all static members
```

Now you can call asList(...) instead of Arrays.asList(...). If the name of a static import collides with a self-created name in the class, the self-created name wins.

This doesn't compile:

```
import static java.util.Arrays; // Arrays is a class, not a member
```

### Passing data among methods

_"Java is a **pass by value** language. This means that a copy of the variable is made and the method receives that copy. Assignments made in the method do not affect the caller."_

Nevertheless, in case of a mutable reference type (such as StringBuilder) you can call a method on the StringBuilder. A copy is made of the variable and that copy will be used in the method. As the copy variable points to the same StringBuilder as the original, changes to the object will be seen by the original variable. There is still just one StringBuilder object. The main thing is that _**assignments**_ made in the method do not affect the caller.

_"If the returned value is not used, the result (of a method) is ignored. Watch for this on the exam. Ignored values are tricky"_

### Overloading methods

Methods can be overloaded in many wys:
- different access modifier
- different return value
- different parameters
- different exceptions

Wat is **not** possible is keeping the signature (name + parameters) exactly the same. This snippet doesn't work:

```
public void fly(int a);
public int fly(int a); // doesn't compile as the signatures are identical
```
_An overloaded method must have a distinctive signature._ 

#### Varargs

_Java treats varargs as if they were an array._

**But** when the parameter of a method is an array, you need to pass an array, while if the method parameter is varargs, you can just provide a comma separated list. This makes varargs pretty useful.

```
fly(new int[] {1,2,3}); // when parameter type is int[]
fly(1,2,3); // when parameter type is varags
```

#### Autoboxing

_When two signatures for a method are available, one having a primitive as parameter and the other the boxed variant of that primitive type, Java will call the one with the primitive type._

The primitive type is seen as the 'most specific' parameter.

```
void fly(int a);
void fly(Integer a);
fly(3); // the first version with int is called 
```

_Generally, Java picks the **most specific** version of a method. Primitives are more specific than objects. A primitive can be passed to a bigger type (int->long) if its own type is not available._

#### Generics

These are not valid overloads:

```
public void walk(List<String> strings){}
public void walk(List<Integer> integers){}  // does not compile
```

The reason it doesn't compile is that the code, once compiled, converts them both into lists of objects. This gives them the same signature which is forbidden. The process is called type erasure.

#### Arrays

Unlike the previous example, this is fine:

```
public static void walk(int[] ints){}
public static void walk(Integer[] integers){}
```

These arrays compile to different types, one int[] and one Integer[]. No type erasure.

#### Putting it all together

The book provides a table that illustrates the selection process of the right signature by a method call:

|Rule|Example of what will be chosen for _**glide(1,2)**_|
|------|-------
|Exact match by type|String glide(int i, int j)|
|Larger primitive type|String glide(long i, long j)|
|Autoboxed type|String glide(Integer i, Integer j)|
|Varargs|String glide(int... nums)|

A method call can pick a signature with a larger primitive type when there is no signature matching its own type. A method can as well pick a signature with the autoboxed type if no signature matches its own type. What is **not** possible is picking a type that requires both conversion _to a larger type **and** to an autoboxed type_.

```
static void play(Long l){}
play(4); // does not compile because it needs two conversions/ int to long, long to Long.
```

_Generally, only one conversion is possible to get a matching signature._

For this reason, this works:

```
static void play(Obj o){}
play(4);  // it only has to convert from int to Integer. The signature can handle any object, including Integer.
```

### Encapsulation

About getters and setters.

Naming convention:
- use 'is' as prefix for method that returns instance field type boolean (isHappy())
- use 'get' as prefix for method that returns instance field type not boolean (getNumberEggs()
- Setter methods begin with set.

I don't know if these conventions are part of the exam.

_"For data to be encapsulated, you don't have to provide setters and getters. As long as the instance variables are private, you are good."_

</details>



<details>
<summary>Chapter 8: Class design</summary>

I skip things.

### Understanding inheritance

#### Accessing the _this_reference

I found this code and I was confused. It turns out you cannot do without this if a method parameter has the same name as an instance variable. Code below compiles but the instance variable color never changes, it is the method variable that sets itself. This is logical as, within the method, the local variable takes precedence over an equally named instance or class variable.

```
Public class Flamingo{
    private String color;
    public void setColor(String color){
        color=color; // wrong, should be this.color
    }
    public static void main(String... whatever){
    Flamingo f = new Flamingo();
    f.setColor("PINK");
    System.out.println(f.color);  // null
    }
}
```

_**Not using this when parameter and instance variable have the same name is a mistake.**_

_Be on the lookout for name conflicts between local and not-local variables. It is not that the code doesn't compile, it is that the result is not what you want._

#### Calling the _super_ reference

Actually you only need a _super_ reference when a method or field is defined both in the current class and in the inherited class. If a parental method is not overridden or hidden, you can do without super.

### Declaring constructors

Like method parameters, constructor parameters can not be of type var.

#### Default constructor

A class constructor can be private. 

Any class that has a valid constructor does not have a default constructor, even if the constructor that is defined programmer is identical to a default constructor. It is kind of a definition thing.

_The term 'default constructor' is reserved for the zero-argument constructor that is generated by the compiler in the absence of a valid constructor._

#### Calling overloaded constructors with _this_

To avoid duplicote constructor code when using overloaded constructors, you can use code from another constructor using _this()_.

_"Despite using the same keyword, this and this() are very different. .. The exam may try to trick you by using both together."_

Example of this():

```
class Hamster{
    private String color;
    private int weight;

    public Hamster(int weight){
        this(weight, "brown"); // you call the other constructor
    }

    public Hamster(int weight, String color){
        this.weight=weight;
        this.color=color;
    }
}
```

#### Calling parent constructors with _super()_

Example:

```
public class Animal{

    private int age;

    public Animal(int age){
        this.age=age;
    }
}

public class Zebra extends Animal{
    public Zebra(int age){
        super(age);  // refers to constructor in animal
    }
    public Zebra(){
        this(4);  // refers to other Zebra constructor with int argument
    }
}
```

_Like calling this(), calling super() can only be used as the first statement of the constructor._

This will not compile:

```
public class Zoo{
    public Zoo(){
        System.out.println("Zoo created");
        super(); // does not compile. It must be the first statement.
    }
}

public class Zoo{
    public Zoo(){
        super();
        System.out.println("Zoo created");
        super(); // does not compile. super() must be the first statement.
    }
}
```

_super and super() are unrelated in the same way as this and this() are unrelated._

About the workings of the compiler: The Java compiler automatically inserts a call to the no-argument super() if you do not explicitly call this() or super() as the first line of the constructor. The following three variants are the same after compiling:

```
class Donkey{}

class Donkey{
    public Donkey{}
}

class Donkey{
    public Donkey{
        super();
    }
}
```

Below a code sample about a principle I figured out earlier. If a parent class has no default constructor, _the child must have a constructor of its own which is not the default constructor._

```
class A{
    public A(int age){}
}

class B extends A{} // does not compile. 
```

The reason why this doesn't compile is that the compiler inserts _super()_ in the default no-argument constructor of class B, which will become:

```
class B extends A{
    super();  // this doesn't work as there is no zero-argument constructor in the parent class
}
```

You can do this to fix it:

```
class B extends A{
    super(10);  
}
```

_"You should be wary of any exam question in which a class defines a constructor that takes arguments and doesn't define a no argument constructor. Be sure to check the code compiles before answering a question about it, especially if any classes inherit it."_

super() always refers to the direct parent class.

#### Constructors and final fields

Final static variables must be assigned a value exact once. 
- For class variables, this means directly after declaration or in a static initializer
- For instance variables, this means at declaration, in instance initializer or in constructor.

_By the time the constructor completes, all final instance variables must be assigned a value. .. Failure to do so will result in a compiler error on the line that declares the constructor._

The compiler is eager to avoid a situation in which final instance variables are not initialized. Example:

```
class House{
    private final int a;
    private final String b;
    { this.a = 10;}
    public House(String b){
        this.b=b;
    }
    public House(){  // COMPILE ERROR
        this.a=2;  // COMPILE ERROR
    }
```

The second constructors enables a situation where b is left unassigned after construction. This is not allowed, thus first compile error. The second compile error is because a is assigned a second time, which is forbidden since it is a final variable.

_"On the exam, be wary of any instance variable marked final. Make sure they are assigned a value on the line where they are declared, in an instance initializer, or a constructor. They should be assigned a value only once."_

You can assign null to a final variable, as long as it gets a value.

#### Order of initialization

- If there is a superclass Y of X, then initialize Y first.
- Process all static variable declarations in the order they appear in the class.
- Process all static initializers in the order they appear in the class.

To be clear: a static initializer in the superclass is thus processed before static variables in the child class.

_A class must be initialized before it is referenced or used._

#### Instance initialization

- If there is a superclass Y of X, then initialize the instance of Y first
- Process all instance variable declarations in the order they appear in the class
- Process all instance initializers in the order they appear in the class
- Initialize the constructor including any overloaded constructors referenced with this

_Generally, superclass before child concrete class, static before instance, variables before initializers, method body from where the call is made comes last._

_Constructors are called from the bottom up, where you must be aware that any constructor starts with super(). This means that the code in the constructor of the super class is called before the code in the constructor of the child class._

My own illustrative example:

```
class Thing{
    Thing(){
        // super() is inserted here by compiler
        System.out.println("Thing ");
    }
}

class Vehicle extends Thing{
    Vehicle(){
        // super() is inserted here by compiler
        System.out.println("Vehicle ");
    }
}


class Car extends Vehicle{
    Car{
        // super() is inserted here by compiler
        System.out.println("Car");
    }
    public static void main(String... p){
        new Car();
    }
}

// Output: Thing Vehicle Car
```

Another example of my own, more extensive. The static initializers go first from top to bottom, and the instance initializers are called right before the constructors.

```
class Thing {
    { System.out.print("Instance initializer Thing - ");}

    static { System.out.print("Static initializer Thing - ");}

    Thing(){
        System.out.println("Thing constructor");
    }
}

class Vehicle extends Thing {
    { System.out.print("Instance initializer Vehicle - ");}

    static { System.out.print("Static initializer Vehicle - ");}

    Vehicle(){
        System.out.println("Vehicle constructor");
    }
}

public class Car extends Vehicle{
    { System.out.print("Instance initializer Car - ");}

    static { System.out.print("Static initializer Car\n");}

    Car(){
        System.out.print("Car constructor");
    }

    public static void main(String... p){
       new Car();
    }
}

// output:
Static initializer Thing - Static initializer Vehicle - Static initializer Car
Instance initializer Thing - Thing constructor
Instance initializer Vehicle - Vehicle constructor
Instance initializer Car - Car constructor
```

it is noteworthy that if the new Car() call in main would be omitted an no instance was created, the only output would be:

```Static initializer Thing - Static initializer Vehicle - Static initializer Car```

This means that both instance initializers and constructors are only called when an instance is created, while for the static stuff to be called it is enough if some static method in the class is called.

#### Reviewing constructor rules

Use the book to read these seven rules, it is too much to copy here but really important.

###Understanding polymorphism

- Casting a reference from a subtype to a supertype doesn't require an explicit cast
- Casting a reference from a supertype to a subtype requires an explicit cast
- The compiler disallows casts to an unrelated class
- At runtime, an invalid cast of a reference to an unrelated type results in a ClassCastException being thrown.

The following code gives a ClassCastException at runtime:

```
class Fruit{}

class Orange extends Fruit{
    public static void main(String[] u){
        Fruit fruit = new Fruit();
        Orange orange = (Orange) fruit; // ClassCastException
    }
}
```

What would have been correct is this:

```
class Fruit{}

class Orange extends Fruit{
    public static void main(String[] u){
        Fruit fruit = new Orange();
        Orange orange = (Orange) fruit;
    }
}
```

You must always look what the real object is. A subclass cannot point to a superclass type object, only vice versa.

#### The instanceof operator

The instanceof operator only works on related classes. It returns false if the reference variable is of a related type but has a value null. It can also return false if two classes are related via a common superclass. If Dog and Cat both extend Animal, ```cat instance of Dog``` is a valid expression that returns false.

#### Polymorphism and method overriding

Method overriding means that all calls to a method related to the class that overrode the method use the overridden version of the method, no matter where the call is done. If the object is of type X, the method called on it will be the one as defined in class X.

#### Overriding vs. hiding members

With overriding you look at the object, with hiding you look at the reference variable and the place from where the call is made.. 

Static methods, instance methods and static methods are not overridden but hidden _**if you redeclare them in the child class.**_ Which version of the method or variable will be used depends on the type of the variable, not on the type of the object. If you do not redeclare the methods in the method or variables is the child class, 

Here a selfmade example to illustrate the difference between overriding and hiding. The method from the parent class is overridden by redeclaring it with the same signature, the instance variable is hidden also by redeclaring it.

```
class Parent{
    String a = "Parent instance variable";
    String doSomething(){return "Parent method";}
}

public class Child extends Parent{
    String a = "Child instance variable";
    String doSomething(){ return "Child method";}

    public static void main(String... p){
        Parent child = new Child();  // Child object, Parent reference type
        System.out.println(child.a);  // a is hidden, not overriden. Prints "Parent instance variable"
        System.out.println(child.doSomething());   // doSomething is overridden, prints "Child method"

        Child child2 = new Child();  // Child object, Child reference type
        System.out.println(child2.a);  // "Child instance variable"
        System.out.println(child2.doSomething());  // "Child method"
    }
}
```

Here a selfmade example showing that it matters where the call is coming from:

```
public class Lemur extends Animal{
    int age = 4;
    public static void main(String... m){
        Lemur lemur = new Lemur();
        System.out.println(lemur.age); // 4 - reference type is Lemur, thus Lemur's variant
        System.out.println(lemur.getAge());  // 3 - method call fromout class Animal
        Animal lemur2 = lemur;
        System.out.println(lemur2.age); // 3 - reference type is Animal, thus Animal's variant
    }
}
class Animal{
    int age = 3;
    int getAge(){
        return this.age;
    }
}
}
```

My generalization: 

_Instance methods can be overridden and from then on, only the object type counts when applying that method._

_Static methods, class variables and instance variables can only be hided and from then on, it is either the reference type or the place from where the call is made that counts._

_There is no way to directly access an instance variable, class variable or static method of class A other than via a reference variable of type A. The only way to do it is indirectly via a get/set method that is an override of a method in the parent class. Why? Because the reference variable can only access method of its own class. It is here that the override manages to do something that cannot be done by shadowing._


Other remarks:

About the protected modifier: a protected modifier for fields and methods is useless if the class they belong to is not public. 

_Again: "Pay close attention on the exam to any class that defines a constructor with arguments and doesn't define a no-argument constructor."_

Local variable can not be static.







</details>

