# Docker

Explanation of the architecture of Docker and how to create a running container of your app and your PostgreSQL database.

## Docker architecture

Everything you need for Docker can be pulled in by installing Docker Desktop. It includes Docker cli, so you can run commands from a shell, and also the so-called daemon, or dockerd, that manages the containers. These two communicate with a REST API, by default over UNIX sockets but you can configure it to communivcate over a network interface (less safe but suitable if client and daemon live on different machines).

The third important element in Docker is the registry, where images are centrally stored. The default registry is Docker Hub but you can create your own, which you might typically do in an organization. 

The other relevant elements of Docker are Docker Compose, a tool to run and define multi-container applications, and Docker Swarm, an orchestration service. The latter is an alternative for Kubernetes.

### Underlying Linux and other software

Docker relies on three Linux elements that predated Docker, namely [chroot](https://man7.org/linux/man-pages/man1/chroot.1.html), [cgroups](https://man7.org/linux/man-pages/man7/cgroups.7.html) and [namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html). The existence of these kernel features shows that the creation of isolated environments, where applications cannot see the underlying OS filesystem or its environment variables, was recognized as something important early on. 

Apart from these Linux kernel features, Docker also relies on [containerd](https://containerd.io/) as the basis for individual containers. Containerd is an open source tool that provides a layer of abstraction upon the basic Linux kernel features and specializes in the running of containers. It gets its instructions from dockerd. Between the kernel features chroot, cgroups and namespaces and containerd lives another creature named runc. It is not part of Linux and written in Go. Both containerd and runc play a large role in the cloud and in kubernetes, and are highly relevant outside of the Docker context.

### A container is a process

While the term container suggests something similar to a file, or at least something that will exist even if the machine is switched off, it isn't. A container is a process. It is built based upon an image, whereby the image is a sort of recipe. Once you have built a container on a machine you can start and stop it and it won't have to rebuild every time, but migrating it means that it needs to be rebuilt on the other system. This was confusing to me, I had hoped or expected that a container would be some sort of transferable file.

## Basic processes

Docker can be fairly well understood when you know the following commands:

- `docker run`
- `docker build`
- `docker pull`

### docker run

The run command presupposes the existence of an image. Any run command requires an image as argument, more specifically the last argument. This image can be an image from Docker Hub or one that you got from your colleague. Take this example, in which a self-generated image is used ('myapp'):

```
docker run -d -p 8080:8080 -v /home/user/data:/app/data myapp:latest
```

Or this one, that starts up a container with a PostgreSQL database:

```
docker run --name my-postgres \
  -e POSTGRES_USER=testuser \
  -e POSTGRES_PASSWORD=testpass \
  -e POSTGRES_DB=testdb \
  -v pgdata:/var/lib/postgresql/data \
  -p 5432:5432 \
  -d postgres:16
```

#### Relevant flags

A complete overview of flags can be found [here](https://docs.docker.com/reference/cli/docker/container/run/):

|flag|meaning|
|----|----|
|--name|Give the container a name|
|-d|Container will run in background|
|-p|Publish a container's port to the host. First number is port within Docker, second is the port for external access|
|-v|Bind a mount volume. For persistence, connects path within container to path in the underlying OS|
|-e|Set environment variable|
|--rm|Automatically remove container and its associated anonymous volumes when it exits|


