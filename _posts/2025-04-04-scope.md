## Scope

I did terrible (34%) on test questions of chapter 12 of [the book](https://www.amazon.com/gp/product/B08DF4R2V9/ref=ppx_yo_dt_b_d_asin_title_351_o00?ie=UTF8&psc=1), basically because I missed fundamentals about scope. Somehow I had not given attention to chapter 2 and 8 and I was still unfamiliar with differences between overriding, shadowing and hiding.

This blog is entirely about scope and I'll do this by reading [chapter 6 paragraph 3 of the Java Language Specification version 11](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.3). Here the rules for all sorts of scope are layed out. I will illustrate every line I read with a code example or some comment. I will skip some lines if they deal with things higher than top-level types (packages, imports etc).

_**"The scope of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is not shadowed (§6.4.1)."**_

Here the term shadowed is used for the first time. The 'a simple name' term is interesting, for example with enum constants. Those are mostly not accessible by their simple name outside of their own type body, with an exception for case statements.

_**"The scope of a top level type (§7.6) is all type declarations in the package in which the top level type is declared."**_

If you create a class, interface or enum, it is accessible within all other classes, interfaces and enums of the same package.

_**"The scope of a declaration of a member m declared in or inherited by a class type C (§8.1.6) is the entire body of C, including any nested type declarations."**_

The members of a class (fields and methods) are accessible anywhere in the class body, even in the most nested parts (think of local methods), by their simple name, unless they are shadowed. Example below is correct, members can be called anywhere if done correctly. It is still important that calling instance variables or instance methods from a static context requires an instance of the outer class.

```
public class Scope {
    static String myStaticString = "myStaticString";
    private Integer myInstanceNumber = 27;

    {myInstanceNumber = 28;}

    void addOne(){myInstanceNumber++;}

    private class Inner{
        private class InnerInner{
                        final int a = 2 + myInstanceNumber;
            void doIt(){
                addOne();
                System.out.println();
                class InnerInnerLocal{
                    { addOne();}
                    int b = myInstanceNumber;
                }}}
    }

    static void someMethod(){
        Scope myMS = new Scope();
        System.out.println(myStaticString + myMS.myInstanceNumber);
    }
}
```

_**"The scope of a declaration of a member m declared in or inherited by an interface type I (§9.1.4) is the entire body of I, including any nested type declarations."**_

This is identical. I wondered what was meant by nested type declarations in the case of interfaces, but you actually can create local classes and static nested classes. The following snippet is an interface with all six member types that are allowed in an interface (public static final class variable, public abstract method, public default method, public static method, private static method and private instance method.

I added an inner static class to it and a local class. In the inner class I shadowed the public final static variable myString, just to practice. All members (fields and methods) are in scope everywhere, unless when they are shadowed (which happens in static inner class Inner at the end).

```
public interface ScopeInterface {

    String myString = "MyString";
    void firstAbstractMethod();

    default String adjustString(String a){
        String b = helpDefaultMethod(a);
        return b;
    }
    private String helpDefaultMethod(String a){
        class localClass {
            void localClassMethod(){ System.out.println(myString);}
        }
        return (myString + "_adjusted");
    }
    static void myStaticMethod(int a){
        myStaticMethodHelper(a);
    }
    private static void myStaticMethodHelper(int a){
        System.out.println(myString + a);
    }
    static class Inner{
        void innerClassMethod(){
            String myString = "A nested String";  // shadowing a member variable
            System.out.println(ScopeInterface.myString + " - " + myString);
        }
    }
}
```

_**"The scope of an enum constant C declared in an enum type T is the body of T, and any case label of a switch statement whose expression is of enum type T (§14.11)."**_




