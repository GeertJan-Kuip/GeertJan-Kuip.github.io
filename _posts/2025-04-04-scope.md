## Scope

I did terrible (34%) on test questions of chapter 12 of [the book](https://www.amazon.com/gp/product/B08DF4R2V9/ref=ppx_yo_dt_b_d_asin_title_351_o00?ie=UTF8&psc=1), basically because I missed fundamentals about scope. Somehow I had not given attention to chapter 2 and 8 and I was still unfamiliar with differences between overriding, shadowing and hiding.

This blog is entirely about scope and I'll do this by reading [chapter 6 paragraph 3 of the Java Language Specification version 11](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.3). Here the rules for all sorts of scope are layed out. I will illustrate every line I read with a code example or some comment. I will skip some lines if they deal with things higher than top-level types (packages, imports etc).

_**"The scope of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is not shadowed (§6.4.1)."**_

Here the term shadowed is used for the first time. The 'a simple name' term is interesting, for example with enum constants. Those are mostly not accessible by their simple name outside of their own type body, with an exception for case statements.

_**"The scope of a top level type (§7.6) is all type declarations in the package in which the top level type is declared."**_

If you create a class, interface or enum, it is accessible within all other classes, interfaces and enums of the same package.

_**"The scope of a declaration of a member m declared in or inherited by a class type C (§8.1.6) is the entire body of C, including any nested type declarations."**_

The members of a class (fields and methods) are accessible anywhere in the class body, even in the most nested parts (think of local methods), by their simple name, unless they are shadowed. Example below is correct, members can be called anywhere if done correctly. It is still important that calling instance variables or instance methods from a static context requires an instance of the outer class.

```
public class Scope {
    static String myStaticString = "myStaticString";
    private Integer myInstanceNumber = 27;

    {myInstanceNumber = 28;}

    void addOne(){myInstanceNumber++;}

    private class Inner{
        private class InnerInner{
                        final int a = 2 + myInstanceNumber;
            void doIt(){
                addOne();
                System.out.println();
                class InnerInnerLocal{
                    { addOne();}
                    int b = myInstanceNumber;
                }}}
    }

    static void someMethod(){
        Scope myMS = new Scope();
        System.out.println(myStaticString + myMS.myInstanceNumber);
    }
}
```

_**"The scope of a declaration of a member m declared in or inherited by an interface type I (§9.1.4) is the entire body of I, including any nested type declarations."**_

This is identical. I wondered what was meant by nested type declarations in the case of interfaces, but you actually can create local classes and static nested classes. The following snippet is an interface with all six member types that are allowed in an interface (public static final class variable, public abstract method, public default method, public static method, private static method and private instance method.

I added an inner static class to it and a local class. In the inner class I shadowed the public final static variable myString, just to practice. All members (fields and methods) are in scope everywhere, unless when they are shadowed (which happens in static inner class Inner at the end).

```
public interface ScopeInterface {

    String myString = "MyString";
    void firstAbstractMethod();

    default String adjustString(String a){
        String b = helpDefaultMethod(a);
        return b;
    }
    private String helpDefaultMethod(String a){
        class localClass {
            void localClassMethod(){ System.out.println(myString);}
        }
        return (myString + "_adjusted");
    }
    static void myStaticMethod(int a){
        myStaticMethodHelper(a);
    }
    private static void myStaticMethodHelper(int a){
        System.out.println(myString + a);
    }
    static class Inner{
        void innerClassMethod(){
            String myString = "A nested String";  // shadowing a member variable
            System.out.println(ScopeInterface.myString + " - " + myString);
        }
    }
}
```

_**"The scope of an enum constant C declared in an enum type T is the body of T, and any case label of a switch statement whose expression is of enum type T (§14.11)."**_

The book pointed out that in switch-case statements, you must use the enum constant without the enum class prefix after _case_ (```case TUESDAY:``` instead of ```case Days.TUESDAY:```). Apparently this is the only occassion where you can use an enum constant without the prefix. (Btw in nowadays Java both versions are allowed).

Within the body of the enum type declaration itself you can, logically, use the enum constant as well. In the review questions of chapter 12 (question 2), the following snippet was presented:

```
public class FlavorsEnum{
    enum Flavors{
        VANILLA, CHOCOLATE, STRAWBERRY;
        static final Flavors DEFAULT = STRAWBERRY;
    }

    public static void main(String... ha){
        // some code
    }
}
```

I was confused about the line ```static final Flavors DEFAULT = STRAWBERRY;``` but this is an example where an enum constant (STRAWBERRY) is used with its simple name within the body of the enum type. It is thus perfectly valid.

_**"The scope of a formal parameter of a method (§8.4.1), constructor (§8.8.1), or lambda expression (§15.27) is the entire body of the method, constructor, or lambda expression."**_

As I didn't give much attention to scope, I noticed that I lived under the assumption that as class and instance variables could hide inherited variables by redeclaring them, and local variables could shadow instance and class variables by redeclaring them, the parameters of lamdbdas, constructors and methods could be hidden as well by redeclaring them. This is not true, they cannot be hidden or shadowed at all. The following snippet contains 3 compile errors: 

```
public class Scope {
    int a;
    
    Scope(int a){
        int a = 5; // not allowed
        this.a = a;
    }

    Predicate<Integer> predicate = b->{
        int b = 3; // not allowed
        return b>0;
    };

    void myMethod(int c){
        int c = 2; // not allowed
        System.out.println(predicate.test(c));
    }
}
```

You cannot redeclare the parameters of lambdas, methods and constructors, as it results in compile errors.

_**"The scope of a class's type parameter (§8.1.2) is the type parameter section of the class declaration, the type parameter section of any superclass or superinterface of the class declaration, and the class body."**_

I just made something very complicated with generics in it. T and U are available throughout the whole class body. I didn't get into the type parameters of the superclass or superinterface.

```
public class Box <T,U> {
    T thing1;
    U thing2;

    public Box(T thing1, U thing2){
        this.thing1 = thing1;
        this.thing2 = thing2;
    }

    public T getThing1(){
        return thing1;
    }

    public U getThing2(){
        return thing2;
    }

    public void printNames(T t, U u){
        class Inner {
            BiConsumer<T,U> printer = (x,y)->{
                System.out.printf("%s - %s", x, y);
            };
            void print(T x, U y){
                printer.accept(x,y);
            }
        }
        Inner inner = new Inner();
        inner.print(t,u);
    }

    public static void main(String[] args){
        Box<String, Integer> myBox = new Box<>("Hello", 57463);
        myBox.printNames(myBox.getThing1(), myBox.getThing2());
    }
}
// output "Hello - 57463"
```

_**"The scope of an interface's type parameter (§9.1.2) is the type parameter section of the interface declaration, the type parameter section of any superinterface of the interface declaration, and the interface body."**_

Here I could make an example that illustrates the second part of this rule: _the type parameter section of any superinterface of the interface declaration._. It is not an interface implementing an interface but a class implementing an interface but the principle is the same.

Note that R and Q have no scope relationship whatsoever. How could they, they might reside in completely different places.

```
public interface CanPrint <R>{  // this R

    void print(R item);         // must correspond with this R. Same scope.
}

class Printer<Q> implements CanPrint<Q>{     // these two Q's are in the same scope

    public void print(Q item){               // and this one also is
        System.out.println(item);
    }

    public static void main(String... args){
        new Printer<String>().print("Hello");
    }
}
```





